"""
UNIFIED Variation Engine - Simplified, Model-Based Approach
Uses candidate combinations with static patterns as guidance in prompts.
"""

import json
from tqdm import tqdm
import logging
import re
from typing import List, Dict, Any, Tuple, Set
from itertools import combinations

from benchdrift.pipeline.comprehensive_variation_engine_v2 import (

    ComprehensiveVariationEngine,
    clean_model_response,
    is_valid_question
)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CONFIGURATION CONSTANTS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# These values control variation generation behavior. Modify as needed for your use case.

# DEFAULT_MAX_COMBINATIONS: Maximum number of candidate combinations to generate per problem
#
# Purpose: Controls how many different variations are generated by varying different
#          combinations of candidates (words, numbers, phrases) in the problem.
#
# Impact: Higher values ‚Üí more variations ‚Üí better coverage but slower generation
#         Lower values ‚Üí fewer variations ‚Üí faster but less comprehensive testing
#
# Recommendation:
#   - Research/comprehensive testing: 50-100
#   - Production/quick testing: 20-30
#   - Debugging/development: 10-20
#
# Note: This is a DEFAULT. Users can override this by passing max_combinations parameter
#       to generate_comprehensive_variations() method.
DEFAULT_MAX_COMBINATIONS = 50


logger = logging.getLogger('BenchDrift.VariationEngine')
class UnifiedVariationEngine(ComprehensiveVariationEngine):
    """Unified approach: One method, model-based variations with static pattern guidance."""
    
    def generate_comprehensive_variations(self, problem: str,
                                       organize_by: str = "debugging_capabilities",
                                       max_combinations: int = DEFAULT_MAX_COMBINATIONS) -> Dict[str, List[Dict[str, Any]]]:
        """
        UNIFIED: Generate variations using intelligent candidate combinations.
        Static patterns included as examples in prompts for model guidance.
        
        Args:
            problem: Input problem
            organize_by: "debugging_capabilities" or "domains"
            max_combinations: Max combinations to generate
            
        Returns: Organized variations
        """
        logger.debug(f"üîç Unified Variation Generation (organized by {organize_by})...")
        
        all_variations = []
        
        # Part 1: Generate generic transformations (counterfactual, interrogative, etc.)
        logger.debug(f"    Part 1: Generating generic transformations...")
        generic_variations = self._generate_generic_transformations(problem)
        all_variations.extend(generic_variations)
        logger.debug(f"    Generated {len(generic_variations)} generic variations")
        
        # Part 2: Generate combination-based variations
        logger.debug(f"    Part 2: Generating combination-based variations...")

        # Use composite-aware detection to properly handle dependencies
        candidates = self._detect_all_candidates_with_composites(problem)
        logger.debug(f"    Found {len(candidates)} transformable candidates (with dependency-aware filtering)")

        if candidates:
            # Apply dependency detection to merge coherent entities
            candidates = self._detect_and_merge_dependencies(problem, candidates)
            logger.debug(f"    After dependency detection: {len(candidates)} candidates")
        
        if candidates and self.model_client:
            combination_variations = self._generate_model_guided_variations(problem, candidates, max_combinations)
            all_variations.extend(combination_variations)
            logger.debug(f"    Generated {len(combination_variations)} combination variations")
        else:
            logger.debug(f"    ‚ö†Ô∏è No candidates or model client - skipping combinations")
        
        logger.debug(f"    Total generated: {len(all_variations)} variations")
        
        # Step 3: Organize by chosen method
        if organize_by == "debugging_capabilities":
            return self._organize_by_debugging_capabilities(all_variations)
        else:
            return self._organize_by_domains(all_variations)
    
    def _detect_all_candidates(self, problem: str) -> List[Dict]:
        """Detect all transformable candidates across domains."""
        candidates = []
        
        # Use existing detection methods
        nl_entities = self.nl_engine.detect_nl_entities(problem)
        math_topics = self.math_engine.detect_math_topics(problem)
        temporal_topics = self.temporal_engine.detect_temporal_topics(problem)
        
        # Collect all candidates
        for topic, matches in math_topics.items():
            for text, pos in matches:
                candidates.append({'text': text, 'pos': pos, 'domain': 'math', 'topic': topic})
        
        for topic, matches in temporal_topics.items():
            for text, pos in matches:
                candidates.append({'text': text, 'pos': pos, 'domain': 'temporal', 'topic': topic})
        
        for entity_type, matches in nl_entities.items():
            for text, pos in matches:
                candidates.append({'text': text, 'pos': pos, 'domain': 'nl', 'topic': entity_type})
        
        return candidates

    def _apply_position_based_replacements(self, problem: str, candidates: List[Dict], selected_variants: Dict[str, str]) -> str:
        """
        Apply replacements using candidate positions to avoid duplicate substitutions.
        Critical for composite candidates to prevent triple-replacement bugs.
        """
        # Create a list of (start_pos, end_pos, original_text, variant_text) tuples
        replacements = []

        for candidate in candidates:
            original_text = candidate['text']
            if original_text in selected_variants:
                variant_text = selected_variants[original_text]

                # Find the position of this candidate in the problem
                candidate_pos = candidate.get('pos', -1)
                if candidate_pos == -1:
                    # Fallback: find position in problem
                    candidate_pos = problem.find(original_text)

                if candidate_pos != -1:
                    end_pos = candidate_pos + len(original_text)
                    replacements.append((candidate_pos, end_pos, original_text, variant_text))
                    logger.debug(f"        üìç Will replace '{original_text}' at position {candidate_pos}-{end_pos} with '{variant_text}'")

        # Sort replacements by position (descending) to avoid position shifts during replacement
        replacements.sort(key=lambda x: x[0], reverse=True)

        # Remove overlapping replacements, prioritizing longer (composite) candidates
        # Sort by length (descending) to prioritize composites, then by position
        replacements.sort(key=lambda x: (-len(x[2]), x[0]))

        filtered_replacements = []
        used_ranges = []

        for start_pos, end_pos, original_text, variant_text in replacements:
            # Check if this replacement overlaps with any existing replacement
            overlap = False
            for used_start, used_end in used_ranges:
                if not (end_pos <= used_start or start_pos >= used_end):  # Overlap detected
                    overlap = True
                    logger.debug(f"        ‚ö†Ô∏è Skipping overlapping replacement of '{original_text}' (shorter) due to composite candidate")
                    break

            if not overlap:
                filtered_replacements.append((start_pos, end_pos, original_text, variant_text))
                used_ranges.append((start_pos, end_pos))
                logger.debug(f"        ‚úÖ Scheduled replacement: '{original_text}' ‚Üí '{variant_text}' at {start_pos}-{end_pos}")

        # Re-sort by position (descending) for right-to-left replacement to avoid position shifts
        filtered_replacements.sort(key=lambda x: x[0], reverse=True)

        # Apply the filtered replacements from right to left (high position to low position)
        modified_problem = problem
        for start_pos, end_pos, original_text, variant_text in filtered_replacements:
            # Double-check that the text at this position matches what we expect
            actual_text = modified_problem[start_pos:end_pos]
            if actual_text == original_text:
                modified_problem = modified_problem[:start_pos] + variant_text + modified_problem[end_pos:]
                logger.debug(f"        ‚úÖ Replaced '{original_text}' with '{variant_text}' at position {start_pos}")
            else:
                logger.debug(f"        ‚ùå Position mismatch: expected '{original_text}' but found '{actual_text}' at {start_pos}")

        return modified_problem

    def _generate_model_guided_variations(self, problem: str, candidates: List[Dict],
                                        max_combinations: int) -> List[Dict]:
        """Generate variations using direct model-based approach with transformation guidance."""

        # Step 1: Calculate all possible combinations exhaustively
        logger.debug(f"    Step 1: Calculating all possible combinations...")
        all_combinations = self._calculate_exhaustive_combinations(candidates)
        logger.debug(f"    Found {len(all_combinations)} total combinations")

        # Step 2: Ask model to select diverse combinations
        logger.debug(f"    Step 2: Asking model to select diverse combinations...")
        selected_combinations = self._model_select_diverse_combinations(problem, candidates, max_combinations)
        logger.debug(f"    Model selected {len(selected_combinations)} diverse combinations")

        # Step 3: Generate complete problem variations directly with transformation guidance
        logger.debug(f"    Step 3: Generating complete problem variations directly...")
        variations = self._generate_direct_variations_batched(problem, selected_combinations)

        return variations

    def _generate_direct_variations_batched(self, problem: str, selected_combinations: List[Dict]) -> List[Dict]:
        """Generate complete problem variations directly with transformation guidance (no bucket/substitution)."""
        logger.debug(f"    üöÄ BATCHING direct variation generation for {len(selected_combinations)} combinations...")

        variations = []

        # Prepare all prompts for batching
        system_prompts = []
        user_prompts = []
        combination_lookup = []  # Track which combination each prompt corresponds to

        for combo_data in selected_combinations:
            candidates = combo_data['candidates']

            # Get transformation mappings as guidance
            transformation_guidance = self._get_static_guidance_for_combination(candidates)

            # Build list of candidates to vary
            candidates_to_vary = [f"'{c['text']}'" for c in candidates]
            candidates_str = ", ".join(candidates_to_vary)

            system_prompt = f"""You are an expert at creating intent-preserving question variations by transforming specific candidates in a problem.

‚ö†Ô∏è CRITICAL FORMAT WARNING ‚ö†Ô∏è
Your response MUST be EXACTLY in this format:
<question>Your varied question here</question>

NOTHING BEFORE the opening tag. NOTHING AFTER the closing tag.
NO explanations, NO commentary, NO markdown, NO extra text.
Responses not matching this EXACT format will be AUTOMATICALLY REJECTED.

CRITICAL TASK: Generate a variation of the original problem by transforming ONLY the specified candidates while preserving the exact answer and intent.

üéØ KEY CONSTRAINTS:
1. Transform ONLY the specified candidates - leave all other parts unchanged
2. Preserve the exact numerical/logical answer
3. Make maximal impact variations (linguistically different as possible)
4. Candidates can be varied in coordinated ways if semantically meaningful
5. Use PLAIN TEXT only - no markdown formatting

‚ö†Ô∏è SEMANTIC COHERENCE REQUIREMENTS (ABSOLUTELY CRITICAL):
‚Ä¢ Time points MUST stay as time points (never ‚Üí duration/frequency)
  ‚úì "2:00 PM" ‚Üí "14:00" | "two in the afternoon" | "fourteen hundred hours"
  ‚úó "2:00 PM" ‚Üí "two hours" | "fifteen hours at noon" | "noon" (12:00 PM)

‚Ä¢ Time point VALUES must be EXACTLY EQUIVALENT:
  ‚úì "8:00 AM" ‚Üí "0800 hours" | "eight in the morning" | "eight o'clock AM"
  ‚úó "8:00 AM" ‚Üí "noon" (12:00 PM) | "fourteen hundred hours" (2:00 PM) | "two in the afternoon"
  CRITICAL: 8:00 AM ‚â† 12:00 PM ‚â† 2:00 PM - these are DIFFERENT times with DIFFERENT answers!

‚Ä¢ Durations MUST stay as durations (never ‚Üí time point)
  ‚úì "2 hours" ‚Üí "120 minutes" | "two hours" | "a couple of hours"
  ‚úó "2 hours" ‚Üí "2:00 PM" | "at two o'clock" | "fourteen hundred hours"

‚Ä¢ Duration VALUES must be EXACTLY EQUIVALENT:
  ‚úì "45 minutes" ‚Üí "three quarters of an hour" | "0.75 hours" | "forty-five minutes"
  ‚úó "45 minutes" ‚Üí "30 minutes" | "half an hour" | "15 minutes"
  CRITICAL: 45 min ‚â† 30 min ‚â† 60 min - these are DIFFERENT durations with DIFFERENT answers!

‚Ä¢ Numbers MUST preserve value (format can change, value cannot!)
  ‚úì "5" ‚Üí "five" | "5.0" | "5.00"
  ‚úó "5" ‚Üí "six" | "4" | "10"

‚Ä¢ Units MUST convert correctly (or not at all)
  ‚úì "60 miles" ‚Üí "96.5 km" (correct conversion)
  ‚úó "60 miles" ‚Üí "60 km" (wrong conversion - breaks answer!)

{transformation_guidance}

üìã EXAMPLES OF CORRECT VARIATION APPROACH:

Example 1: Vary ONLY combination candidates, not other parts
Original: "John has 3 apples and Mary has 5 oranges. How many fruits total?"
Candidates to vary: ['3', 'apples']
‚úì CORRECT: "John has five apples and Mary has 5 oranges. How many fruits total?"
   ‚Üí Only "3"‚Üí"five" and "apples"‚Üí"apples" varied; "Mary", "5", "oranges" unchanged
‚úó WRONG: "John has five apples and Mary has ten oranges. How many fruits total?"
   ‚Üí Changed "5" which was NOT in the combination

Example 2: Substitution coherence (CRITICAL - avoid gibberish!)
Original: "Find 3/4 of 20"
Candidates to vary: ['3/4']
‚úì CORRECT: "Find 0.75 of 20"
   ‚Üí Direct substitution makes grammatical sense
‚úó WRONG: "Find three quarters of a pizza of 20"
   ‚Üí Gibberish when substituted!

Example 3: Duration transformation
Original: "It takes 2 hours to complete the task"
Candidates to vary: ['2 hours']
‚úì CORRECT: "It takes 120 minutes to complete the task"
   ‚Üí Alternative: "two hours" | "2 hr" | "a couple of hours"
‚úó WRONG: "It takes one hundred twenty minutes and forty five seconds per wall times four"
   ‚Üí Nonsensical, breaks meaning entirely

Example 4: Format specifier preservation
Original: "Answer in H:M:S format"
Candidates to vary: ['H:M:S']
‚úì CORRECT: "Answer in hours:minutes:seconds format"
   ‚Üí Alternative: "HH:MM:SS" | "time format"
‚úó WRONG: "Answer in nine hours forty three minutes format"
   ‚Üí Changed from format specifier to specific value!

Example 5: Coordinated/dependent variations (KEY CAPABILITY)
Original: "A dozen eggs cost $6. What's the price per egg?"
Candidates to vary: ['dozen', 'eggs', '$6']
‚úì CORRECT: "A case of bottles costs 6 dollars. What's the price per bottle?"
   ‚Üí "dozen eggs" ‚Üí "case of bottles" (coordinated semantic change)
   ‚Üí "$6" ‚Üí "6 dollars" (format change)
   ‚Üí Answer preserved: $0.50 per unit
‚úó WRONG: "A dozen bottles cost $6. What's the price per egg?"
   ‚Üí Inconsistent: changed "eggs" to "bottles" but kept "per egg"

Example 4: Coordinated entity changes
Original: "Car travels 120 miles in 3 hours. What's the speed?"
Candidates to vary: ['Car', '120', 'miles', '3', 'hours']
‚úì CORRECT: "Bicycle covers 120 kilometers in 3 hours. What's the speed?"
   ‚Üí "Car" ‚Üí "Bicycle", "miles" ‚Üí "kilometers" (semantically coordinated)
   ‚Üí Answer structure preserved: 40 units/hour
‚úó WRONG: "Bicycle travels 120 miles in 3 hours. What's the speed?"
   ‚Üí Only changed vehicle, missed opportunity for coordinated variation

Example 5: Mathematical coordinated changes
Original: "If basket has 5 rows of 3 apples each, how many total?"
Candidates to vary: ['5', '3', 'apples']
‚úì CORRECT: "If crate has five columns of three oranges each, how many total?"
   ‚Üí "5"‚Üí"five", "3"‚Üí"three" (number format)
   ‚Üí "basket"‚Üí"crate", "rows"‚Üí"columns", "apples"‚Üí"oranges" (coordinated nouns)
   ‚Üí Answer: 15 items (preserved)
‚úó WRONG: "If basket has five rows of 3 apples each, how many total?"
   ‚Üí Only varied "5", didn't maximize impact

üö® ABSOLUTE REQUIREMENTS:
‚Ä¢ ONLY vary the specified candidates - everything else stays exactly the same
‚Ä¢ Answer must remain identical (verify before submitting)
‚Ä¢ Make variations as linguistically different as possible (maximal impact)
‚Ä¢ Coordinate related candidates when semantically appropriate
‚Ä¢ No markdown, formatting, or meta-commentary

üéØ DIVERSITY & SOPHISTICATION GUIDELINES:
Make each variation SUBSTANTIALLY DIFFERENT using:
‚Ä¢ Word choice: formal/informal/technical language styles
‚Ä¢ Complexity: simple/detailed/descriptive phrasing
‚Ä¢ Format: numeric/textual/abbreviated representations
‚Ä¢ Structure: active/passive voice, direct/indirect phrasing

DOMAIN-SPECIFIC STRATEGIES:
‚Ä¢ Mathematical: word forms, notations, descriptive phrases, structural equivalents
‚Ä¢ Temporal: different formats, descriptive phrases, relative expressions, conversions
‚Ä¢ Linguistic: synonyms, formal/informal variants, grammatical transformations
‚Ä¢ Format specifiers: equivalent descriptions, technical vs plain language

CONTEXTUAL COHERENCE:
‚úì Consider grammatical role of element in sentence
‚úì Ensure numerical/logical consistency
‚úì Maintain appropriate level of specificity
‚úì Keep format indicators as format indicators (not specific values!)
‚úì Preserve temporal/mathematical relationships

‚ö†Ô∏è FINAL FORMAT REMINDER - READ CAREFULLY ‚ö†Ô∏è

CORRECT (will be accepted):
<question>If bicycle covers 120 kilometers in 3 hours. What's the speed?</question>

WRONG (will be REJECTED):
‚ùå Here is my variation: <question>If bicycle covers...</question>
‚ùå <question>If bicycle covers...</question> I changed "car" to "bicycle"
‚ùå ```<question>If bicycle covers...</question>```
‚ùå The variation is: "If bicycle covers..."
‚ùå <question>If bicycle covers...</question>\n\nExplanation: I transformed...

Your response must be EXACTLY: <question> + varied problem + </question>
Zero tolerance for deviations. Automated parsing will reject anything else."""

            user_prompt = f"""Original Problem:
{problem}

Candidates to Vary (ONLY these):
{candidates_str}

Generate ONE complete problem variation that:
1. Transforms ONLY the specified candidates
2. Preserves the exact answer
3. Makes maximum linguistic impact
4. Uses coordinated variations where semantically appropriate"""

            system_prompts.append(system_prompt)
            user_prompts.append(user_prompt)
            combination_lookup.append(combo_data)

        # BATCH CALL: Process all combinations at once
        try:
            logger.debug(f"        üì¶ Batching {len(selected_combinations)} direct variation prompts...")
            if hasattr(self.model_client, 'get_model_response'):
                responses = self.model_client.get_model_response(system_prompts, user_prompts)
            else:
                # Fallback for non-batching clients
                responses = []
                for i, (sys_prompt, user_prompt) in enumerate(zip(system_prompts, user_prompts)):
                    response = str(self.model_client.generate(user_prompt, sys_prompt))
                    responses.append(response)

            # Process all responses
            for i, (response, combo_data) in enumerate(zip(responses, combination_lookup)):
                candidates = combo_data['candidates']

                # Extract question using robust multi-strategy parsing
                extracted_question = self._extract_variation_from_response(response)

                if extracted_question:
                    candidate_texts = [c['text'] for c in candidates]
                    variation = {
                        'original_problem': problem,
                        'modified_problem': extracted_question,
                        'transformation_type': f'direct_combination_{combo_data["size"]}way',
                        'candidates_transformed': candidate_texts,
                        'combination_size': combo_data['size'],
                        'domains_involved': list(set(c['domain'] for c in combo_data['candidates'])),
                        'cross_domain': len(set(c['domain'] for c in combo_data['candidates'])) > 1,
                        'confidence': 'model_generated_direct'
                    }
                    variations.append(variation)
                    logger.debug(f"          ‚úì Generated direct variation {i+1}/{len(selected_combinations)}")
                else:
                    logger.debug(f"          ‚ùå Failed to extract valid variation {i+1}/{len(selected_combinations)}")
                    logger.debug(f"               Response preview: {response[:200]}...")

            # BATCH VALIDATE AND CORRECT all variations at once
            if variations:
                variations = self._batch_validate_and_correct_variations(problem, variations)

        except Exception as e:
            logger.debug(f"        ‚ùå Batch processing failed: {e}")
            import traceback
            traceback.print_exc()

        logger.debug(f"    ‚úÖ Batch completed: {len(variations)} direct variations generated")
        return variations

    def _generate_direct_variations_cross_problem_batched(self,
                                                         problems_with_combinations: List[Tuple[int, str, str, List[Dict]]],
                                                         rectify_invalid: bool = False) -> Dict[int, List[Dict]]:
        """
        Generate direct variations for MULTIPLE problems in ONE batch call (cross-problem batching).

        This is the CORE method for cross-problem batching efficiency.
        Collects variation requests from multiple problems and executes in a single API call.

        Args:
            problems_with_combinations: List of (problem_idx, problem_text, ground_truth, selected_combinations)
            rectify_invalid: If True, rectify invalid variations; if False, drop them (default: False)

        Returns:
            Dict mapping problem_idx -> list of variations
        """
        logger.debug(f"    üöÄ CROSS-PROBLEM BATCHING: Generating direct variations for {len(problems_with_combinations)} problems...")

        variations_map = {}

        # Prepare all prompts for batching across ALL problems
        system_prompts = []
        user_prompts = []
        request_mapping = []  # Track (problem_idx, combo_data) for each request

        total_requests = 0
        # Store ground truth for each problem for later use in rectification
        ground_truth_map = {}
        for problem_idx, problem_text, ground_truth, selected_combinations in problems_with_combinations:
            ground_truth_map[problem_idx] = ground_truth
            for combo_data in selected_combinations:
                candidates = combo_data['candidates']

                # Get transformation mappings as guidance
                transformation_guidance = self._get_static_guidance_for_combination(candidates)

                # Build list of candidates to vary
                candidates_to_vary = [f"'{c['text']}'" for c in candidates]
                candidates_str = ", ".join(candidates_to_vary)

                system_prompt = f"""You are an expert at creating intent-preserving question variations by transforming specific candidates in a problem.

‚ö†Ô∏è CRITICAL FORMAT WARNING ‚ö†Ô∏è
Your response MUST be EXACTLY in this format:
<question>Your varied question here</question>

NOTHING BEFORE the opening tag. NOTHING AFTER the closing tag.
NO explanations, NO commentary, NO markdown, NO extra text.
Responses not matching this EXACT format will be AUTOMATICALLY REJECTED.

CRITICAL TASK: Generate a variation of the original problem by transforming ONLY the specified candidates while preserving the exact answer and intent.

üéØ KEY CONSTRAINTS:
1. Transform ONLY the specified candidates - leave all other parts unchanged
2. Preserve the exact numerical/logical answer
3. Make maximal impact variations (linguistically different as possible)
4. Candidates can be varied in coordinated ways if semantically meaningful
5. Use PLAIN TEXT only - no markdown formatting

‚ö†Ô∏è SEMANTIC COHERENCE REQUIREMENTS (ABSOLUTELY CRITICAL):
‚Ä¢ Time points MUST stay as time points (never ‚Üí duration/frequency)
  ‚úì "2:00 PM" ‚Üí "14:00" | "two in the afternoon" | "fourteen hundred hours"
  ‚úó "2:00 PM" ‚Üí "two hours" | "fifteen hours at noon" | "noon" (12:00 PM)

‚Ä¢ Time point VALUES must be EXACTLY EQUIVALENT:
  ‚úì "8:00 AM" ‚Üí "0800 hours" | "eight in the morning" | "eight o'clock AM"
  ‚úó "8:00 AM" ‚Üí "noon" (12:00 PM) | "fourteen hundred hours" (2:00 PM) | "two in the afternoon"
  CRITICAL: 8:00 AM ‚â† 12:00 PM ‚â† 2:00 PM - these are DIFFERENT times with DIFFERENT answers!

‚Ä¢ Durations MUST stay as durations (never ‚Üí time point)
  ‚úì "2 hours" ‚Üí "120 minutes" | "two hours" | "a couple of hours"
  ‚úó "2 hours" ‚Üí "2:00 PM" | "at two o'clock" | "fourteen hundred hours"

‚Ä¢ Duration VALUES must be EXACTLY EQUIVALENT:
  ‚úì "45 minutes" ‚Üí "three quarters of an hour" | "0.75 hours" | "forty-five minutes"
  ‚úó "45 minutes" ‚Üí "30 minutes" | "half an hour" | "15 minutes"
  CRITICAL: 45 min ‚â† 30 min ‚â† 60 min - these are DIFFERENT durations with DIFFERENT answers!

‚Ä¢ Numbers MUST preserve value (format can change, value cannot!)
  ‚úì "5" ‚Üí "five" | "5.0" | "5.00"
  ‚úó "5" ‚Üí "six" | "4" | "10"

‚Ä¢ Units MUST convert correctly (or not at all)
  ‚úì "60 miles" ‚Üí "96.5 km" (correct conversion)
  ‚úó "60 miles" ‚Üí "60 km" (wrong conversion - breaks answer!)

{transformation_guidance}

üìã EXAMPLES OF CORRECT VARIATION APPROACH:

Example 1: Vary ONLY combination candidates, not other parts
Original: "John has 3 apples and Mary has 5 oranges. How many fruits total?"
Candidates to vary: ['3', 'apples']
‚úì CORRECT: "John has five apples and Mary has 5 oranges. How many fruits total?"
   ‚Üí Only "3"‚Üí"five" and "apples"‚Üí"apples" varied; "Mary", "5", "oranges" unchanged
‚úó WRONG: "John has five apples and Mary has ten oranges. How many fruits total?"
   ‚Üí Changed "5" which was NOT in the combination

Example 2: Substitution coherence (CRITICAL - avoid gibberish!)
Original: "Find 3/4 of 20"
Candidates to vary: ['3/4']
‚úì CORRECT: "Find 0.75 of 20"
   ‚Üí Direct substitution makes grammatical sense
‚úó WRONG: "Find three quarters of a pizza of 20"
   ‚Üí Gibberish when substituted!

Example 3: Duration transformation
Original: "It takes 2 hours to complete the task"
Candidates to vary: ['2 hours']
‚úì CORRECT: "It takes 120 minutes to complete the task"
   ‚Üí Alternative: "two hours" | "2 hr" | "a couple of hours"
‚úó WRONG: "It takes one hundred twenty minutes and forty five seconds per wall times four"
   ‚Üí Nonsensical, breaks meaning entirely

Example 4: Format specifier preservation
Original: "Answer in H:M:S format"
Candidates to vary: ['H:M:S']
‚úì CORRECT: "Answer in hours:minutes:seconds format"
   ‚Üí Alternative: "HH:MM:SS" | "time format"
‚úó WRONG: "Answer in nine hours forty three minutes format"
   ‚Üí Changed from format specifier to specific value!

Example 5: Coordinated/dependent variations (KEY CAPABILITY)
Original: "A dozen eggs cost $6. What's the price per egg?"
Candidates to vary: ['dozen', 'eggs', '$6']
‚úì CORRECT: "A case of bottles costs 6 dollars. What's the price per bottle?"
   ‚Üí "dozen eggs" ‚Üí "case of bottles" (coordinated semantic change)
   ‚Üí "$6" ‚Üí "6 dollars" (format change)
   ‚Üí Answer preserved: $0.50 per unit
‚úó WRONG: "A dozen bottles cost $6. What's the price per egg?"
   ‚Üí Inconsistent: changed "eggs" to "bottles" but kept "per egg"

Example 4: Coordinated entity changes
Original: "Car travels 120 miles in 3 hours. What's the speed?"
Candidates to vary: ['Car', '120', 'miles', '3', 'hours']
‚úì CORRECT: "Bicycle covers 120 kilometers in 3 hours. What's the speed?"
   ‚Üí "Car" ‚Üí "Bicycle", "miles" ‚Üí "kilometers" (semantically coordinated)
   ‚Üí Answer structure preserved: 40 units/hour
‚úó WRONG: "Bicycle travels 120 miles in 3 hours. What's the speed?"
   ‚Üí Only changed vehicle, missed opportunity for coordinated variation

Example 5: Mathematical coordinated changes
Original: "If basket has 5 rows of 3 apples each, how many total?"
Candidates to vary: ['5', '3', 'apples']
‚úì CORRECT: "If crate has five columns of three oranges each, how many total?"
   ‚Üí "5"‚Üí"five", "3"‚Üí"three" (number format)
   ‚Üí "basket"‚Üí"crate", "rows"‚Üí"columns", "apples"‚Üí"oranges" (coordinated nouns)
   ‚Üí Answer: 15 items (preserved)
‚úó WRONG: "If basket has five rows of 3 apples each, how many total?"
   ‚Üí Only varied "5", didn't maximize impact

üö® ABSOLUTE REQUIREMENTS:
‚Ä¢ ONLY vary the specified candidates - everything else stays exactly the same
‚Ä¢ Answer must remain identical (verify before submitting)
‚Ä¢ Make variations as linguistically different as possible (maximal impact)
‚Ä¢ Coordinate related candidates when semantically appropriate
‚Ä¢ No markdown, formatting, or meta-commentary

üéØ DIVERSITY & SOPHISTICATION GUIDELINES:
Make each variation SUBSTANTIALLY DIFFERENT using:
‚Ä¢ Word choice: formal/informal/technical language styles
‚Ä¢ Complexity: simple/detailed/descriptive phrasing
‚Ä¢ Format: numeric/textual/abbreviated representations
‚Ä¢ Structure: active/passive voice, direct/indirect phrasing

DOMAIN-SPECIFIC STRATEGIES:
‚Ä¢ Mathematical: word forms, notations, descriptive phrases, structural equivalents
‚Ä¢ Temporal: different formats, descriptive phrases, relative expressions, conversions
‚Ä¢ Linguistic: synonyms, formal/informal variants, grammatical transformations
‚Ä¢ Format specifiers: equivalent descriptions, technical vs plain language

CONTEXTUAL COHERENCE:
‚úì Consider grammatical role of element in sentence
‚úì Ensure numerical/logical consistency
‚úì Maintain appropriate level of specificity
‚úì Keep format indicators as format indicators (not specific values!)
‚úì Preserve temporal/mathematical relationships

‚ö†Ô∏è FINAL FORMAT REMINDER - READ CAREFULLY ‚ö†Ô∏è

CORRECT (will be accepted):
<question>If bicycle covers 120 kilometers in 3 hours. What's the speed?</question>

WRONG (will be REJECTED):
‚ùå Here is my variation: <question>If bicycle covers...</question>
‚ùå <question>If bicycle covers...</question> I changed "car" to "bicycle"
‚ùå ```<question>If bicycle covers...</question>```
‚ùå The variation is: "If bicycle covers..."
‚ùå <question>If bicycle covers...</question>\n\nExplanation: I transformed...

Your response must be EXACTLY: <question> + varied problem + </question>
Zero tolerance for deviations. Automated parsing will reject anything else."""

                user_prompt = f"""Original Problem:
{problem_text}

Candidates to Vary (ONLY these):
{candidates_str}

Generate ONE complete problem variation that:
1. Transforms ONLY the specified candidates
2. Preserves the exact answer
3. Makes maximum linguistic impact
4. Uses coordinated variations where semantically appropriate"""

                system_prompts.append(system_prompt)
                user_prompts.append(user_prompt)
                request_mapping.append((problem_idx, combo_data))
                total_requests += 1

        if not system_prompts:
            logger.debug(f"        ‚ÑπÔ∏è  No direct variation requests to batch")
            return {}

        logger.debug(f"        üì¶ Batching {total_requests} direct variation requests across {len(problems_with_combinations)} problems...")

        # BATCH CALL: Process all combinations from all problems at once
        try:
            if hasattr(self.model_client, 'get_model_response'):
                responses = self.model_client.get_model_response(system_prompts, user_prompts)
            else:
                # Fallback for non-batching clients
                responses = []
                for i, (sys_prompt, user_prompt) in enumerate(zip(system_prompts, user_prompts)):
                    if i % 50 == 0:
                        logger.debug(f"          Progress: {i}/{len(system_prompts)}")
                    response = str(self.model_client.generate(user_prompt, sys_prompt))
                    responses.append(response)

            # Process all responses and organize by problem
            successful_variations = 0
            for i, (response, (problem_idx, combo_data)) in enumerate(zip(responses, request_mapping)):
                candidates = combo_data['candidates']

                # Extract question using strict parsing
                extracted_question = self._extract_variation_from_response(response)

                if extracted_question:
                    # Get the original problem text
                    original_problem = next(p[1] for p in problems_with_combinations if p[0] == problem_idx)

                    candidate_texts = [c['text'] for c in candidates]
                    variation = {
                        'original_problem': original_problem,
                        'modified_problem': extracted_question,
                        'transformation_type': f'direct_combination_{combo_data["size"]}way',
                        'candidates_transformed': candidate_texts,
                        'combination_size': combo_data['size'],
                        'domains_involved': list(set(c['domain'] for c in combo_data['candidates'])),
                        'cross_domain': len(set(c['domain'] for c in combo_data['candidates'])) > 1,
                        'confidence': 'model_generated_direct',
                        'generation_method': 'cross_problem_batched'
                    }

                    if problem_idx not in variations_map:
                        variations_map[problem_idx] = []
                    variations_map[problem_idx].append(variation)
                    successful_variations += 1
                else:
                    logger.debug(f"          ‚ùå Failed to extract valid variation for problem {problem_idx}")

            # Note: Validation moved to separate stage 1a (validation stage)
            total_generated = sum(len(v) for v in variations_map.values())
            logger.debug(f"        ‚úÖ Cross-problem batch completed: {total_generated}/{total_requests} direct variations generated (validation will be done in stage 1a)")

        except Exception as e:
            logger.debug(f"        ‚ùå Cross-problem batch processing failed: {e}")
            import traceback
            traceback.print_exc()

        return variations_map

    def _batch_validate_all_variations(self, problems_with_variations: List[Tuple[str, List[Dict]]], batch_size: int = 50) -> Dict[int, List[int]]:
        """
        Batch validate ALL variations across ALL problems with chunking.

        Args:
            problems_with_variations: List of (problem_text, variations_list) tuples
            batch_size: Maximum variations per API call (default: 50, same as llm_judge)

        Returns:
            Dict mapping problem_idx -> list of invalid variation indices
        """
        # Flatten all variations for batch validation
        all_variations = []
        variation_mapping = []  # (problem_idx, var_idx_in_problem, variation)

        for problem_idx, (problem_text, variations) in enumerate(problems_with_variations):
            for var_idx, variation in enumerate(variations):
                all_variations.append(variation)
                variation_mapping.append((problem_idx, var_idx, problem_text))

        if not all_variations:
            return {}

        total_variations = len(all_variations)
        total_batches = (total_variations + batch_size - 1) // batch_size

        logger.debug(f"\nüîç GLOBAL VALIDATION: Validating {total_variations} variations across {len(problems_with_variations)} problems...")
        logger.debug(f"   Batch size: {batch_size}, Total batches: {total_batches}")

        # System prompt (same for all batches)
        system_prompt = """You are an expert at validating whether problem variations preserve the original intent and answer.

Your task: For each variation, determine if it has the EXACT SAME numerical answer as the original problem.

CRITICAL: VERIFY unit conversions are mathematically correct by CALCULATING the conversion:

DURATION CONVERSIONS (calculate before validating):
‚úì "30 minutes" ‚Üí "1800 seconds" = VALID (30√ó60=1800 ‚úì)
‚úì "45 minutes" ‚Üí "three quarters of an hour" = VALID (45 = 60√ó0.75 ‚úì)
‚úó "30 minutes" ‚Üí "three quarters of an hour" = INVALID (30 ‚â† 60√ó0.75=45 ‚úó)
‚úó "45 minutes" ‚Üí "half an hour" = INVALID (45 ‚â† 60√ó0.5=30 ‚úó)

TIME POINT CONVERSIONS (calculate before validating):
‚úì "2:00 PM" ‚Üí "840 minutes past midnight" = VALID (14:00, 14√ó60=840 ‚úì)
‚úì "9:00 AM" ‚Üí "540 minutes past midnight" = VALID (9√ó60=540 ‚úì)
‚úó "2:00 PM" ‚Üí "1200 minutes past midnight" = INVALID (14√ó60=840 ‚â† 1200 ‚úó, 1200√∑60=20:00=8PM)
‚úó "9:00 AM" ‚Üí "600 minutes past midnight" = INVALID (9√ó60=540 ‚â† 600 ‚úó)

OTHER INVALID CHANGES:
‚úó "8:00 AM" ‚Üí "noon" = INVALID (8:00 AM ‚â† 12:00 PM)
‚úó "2 hours" ‚Üí "3 hours" = INVALID (2 ‚â† 3)
‚úó "5 apples" ‚Üí "10 apples" = INVALID (5 ‚â† 10)

VALIDATION PROCESS:
1. Identify each numerical value in both original and variation
2. For conversions, CALCULATE if they're equivalent (don't guess!)
3. Mark INVALID if ANY value changes to a non-equivalent amount

BE STRICT: If you cannot verify a conversion is correct, mark as INVALID."""

        # Use variation model for validation (not judge model to avoid dual client initialization)
        model_client = self.model_client
        logger.debug(f"   üìã Using variation model for validation...")

        # Process in batches (same pattern as llm_judge_answer_checker.py)
        invalid_by_problem = {}

        try:
            validation_range = range(0, total_variations, batch_size)
            if not getattr(self.model_client, 'verbose', False):
                validation_range = tqdm(validation_range, desc='Validating', unit='batch')
            for batch_idx in validation_range:
                batch_num = batch_idx // batch_size + 1
                logger.debug(f"   üîÑ Processing validation batch {batch_num}/{total_batches} ({min(batch_size, total_variations - batch_idx)} variations)...")

                # Get batch
                batch_variations = all_variations[batch_idx:batch_idx + batch_size]
                batch_mapping = variation_mapping[batch_idx:batch_idx + batch_size]

                # Build user prompt for this batch
                user_prompt_parts = []
                for i, (variation, (problem_idx, var_idx, problem_text)) in enumerate(zip(batch_variations, batch_mapping)):
                    # Show FULL text - validator needs to see all numbers to validate properly
                    orig_text = str(problem_text) if problem_text else "N/A"
                    var_text = str(variation.get('modified_problem', '')) if variation.get('modified_problem') else "N/A"
                    user_prompt_parts.append(f"""
{i+1}. Original: {orig_text}
   Variation: {var_text}""")

                user_prompt = f"""Validate these {len(batch_variations)} variations:
{"".join(user_prompt_parts)}

For EACH variation (1 to {len(batch_variations)}), respond EXACTLY as:
1: VALID or INVALID
2: VALID or INVALID
...

BE STRICT: Any numerical value change means INVALID."""

                # Standard calling pattern (same as everywhere else)
                if hasattr(model_client, 'get_model_response'):
                    responses = model_client.get_model_response([system_prompt], [user_prompt])
                    response = responses[0] if responses else ""
                else:
                    response = str(model_client.generate(user_prompt, system_prompt))

                # Parse validation flags for this batch
                response_lines = str(response).strip().split('\n')

                for i, (variation, (problem_idx, var_idx, problem_text)) in enumerate(zip(batch_variations, batch_mapping)):
                    # Look for line starting with "i+1:"
                    found = False
                    for line in response_lines:
                        if line.strip().upper().startswith(f"{i+1}:"):
                            found = True
                            if 'INVALID' in line.upper():
                                if problem_idx not in invalid_by_problem:
                                    invalid_by_problem[problem_idx] = []
                                invalid_by_problem[problem_idx].append(var_idx)
                            break

                    if not found:
                        # Could not parse - mark as invalid for safety
                        if problem_idx not in invalid_by_problem:
                            invalid_by_problem[problem_idx] = []
                        invalid_by_problem[problem_idx].append(var_idx)

            total_invalid = sum(len(v) for v in invalid_by_problem.values())
            logger.debug(f"   ‚úÖ Global validation complete: {total_invalid}/{len(all_variations)} variations need correction")

            return invalid_by_problem

        except Exception as e:
            import traceback
            logger.debug(f"   ‚ö†Ô∏è  Global validation failed: {e}")
            logger.debug(f"   Error type: {type(e).__name__}")
            if hasattr(e, '__traceback__'):
                logger.debug(f"   Traceback: {traceback.format_exc()[:200]}")
            logger.debug(f"   Skipping validation - all variations treated as valid")
            return {}

    def _batch_rectify_across_problems(self, problems_with_invalid: List[Tuple[int, str, str, List[Dict], List[int]]], batch_size: int = 50) -> Dict[int, List[Dict]]:
        """
        Batch rectify invalid variations across ALL problems with chunking.

        Args:
            problems_with_invalid: List of (problem_idx, problem_text, baseline_answer, variations, invalid_indices)
            batch_size: Maximum variations per API call (default: 50, same as llm_judge)

        Returns:
            Dict mapping problem_idx -> list of corrected variations
        """
        # Flatten all invalid variations for batching
        all_invalid_items = []
        for problem_idx, problem_text, baseline_answer, variations, invalid_indices in problems_with_invalid:
            for inv_idx in invalid_indices:
                all_invalid_items.append((problem_idx, problem_text, baseline_answer, variations, inv_idx, variations[inv_idx].copy()))

        total_invalid = len(all_invalid_items)
        total_batches = (total_invalid + batch_size - 1) // batch_size

        logger.debug(f"\nüîß BATCHED RECTIFICATION: Correcting {total_invalid} invalid variations across {len(problems_with_invalid)} problems...")
        logger.debug(f"   Batch size: {batch_size}, Total batches: {total_batches}")

        # System prompt (same for all batches)
        system_prompt = """You are an expert at fixing problem variations to preserve intent while maintaining linguistic diversity.

Your task: For EACH problem, correct ONLY its invalid variations with minimal changes.

Key principles:
‚Ä¢ Fix ONLY the parts that break the answer (wrong times, durations, values)
‚Ä¢ Keep all other linguistic variations intact
‚Ä¢ Preserve the transformation style (formal, informal, domain shift, etc.)
‚Ä¢ Make minimal changes - don't rewrite everything"""

        # Use variation model for rectification (not judge model to avoid dual client initialization)
        model_client = self.model_client
        logger.debug(f"   üìã Using variation model for rectification...")

        # Process in batches (same pattern as llm_judge_answer_checker.py)
        corrected_by_problem = {}

        try:
            for batch_idx in range(0, total_invalid, batch_size):
                batch_num = batch_idx // batch_size + 1
                logger.debug(f"   üîÑ Processing rectification batch {batch_num}/{total_batches} ({min(batch_size, total_invalid - batch_idx)} variations)...")

                # Get batch
                batch_items = all_invalid_items[batch_idx:batch_idx + batch_size]

                # Build user prompt for this batch
                user_prompt_parts = []
                for i, (problem_idx, problem_text, baseline_answer, variations, inv_idx, orig_var) in enumerate(batch_items):
                    if i == 0 or batch_items[i-1][0] != problem_idx:
                        # New problem - add header
                        user_prompt_parts.append(f"""
PROBLEM {problem_idx + 1}:
Original: {problem_text}
Baseline Answer: {baseline_answer}

Invalid variations to correct:""")
                    user_prompt_parts.append(f"{i+1}: {orig_var['modified_problem']}")

                user_prompt = "".join(user_prompt_parts)
                user_prompt += f"""

For EACH invalid variation above (1 to {len(batch_items)}), provide a corrected version that:
1. Preserves the SAME answer as the baseline
2. Keeps linguistic variations intact
3. Fixes ONLY the values that broke the answer

Format your response EXACTLY as:
1: <question>Corrected variation 1 here</question>
2: <question>Corrected variation 2 here</question>
...

Use <question></question> tags for each corrected variation."""

                # Standard calling pattern (same as everywhere else)
                if hasattr(model_client, 'get_model_response'):
                    responses = model_client.get_model_response([system_prompt], [user_prompt])
                    response = responses[0] if responses else ""
                else:
                    response = str(model_client.generate(user_prompt, system_prompt))

                # Parse corrected variations for this batch
                response_text = str(response)

                for i, (problem_idx, problem_text, baseline_answer, variations, inv_idx, orig_var) in enumerate(batch_items):
                    # Try to extract corrected variation for this batch index
                    pattern = f"{i+1}:"
                    if pattern in response_text:
                        start = response_text.find(pattern) + len(pattern)
                        question_start = response_text.find("<question>", start)
                        question_end = response_text.find("</question>", start)

                        if question_start != -1 and question_end != -1:
                            corrected_text = response_text[question_start+10:question_end].strip()

                            # Update the original variation with corrected text
                            corrected_var = orig_var.copy()
                            corrected_var['modified_problem'] = corrected_text

                            if problem_idx not in corrected_by_problem:
                                corrected_by_problem[problem_idx] = []
                            corrected_by_problem[problem_idx].append((inv_idx, corrected_var))

            total_corrected = sum(len(v) for v in corrected_by_problem.values())
            logger.debug(f"   ‚úÖ Batch rectification completed: {total_corrected}/{total_invalid} variations corrected")

            return corrected_by_problem

        except Exception as e:
            logger.debug(f"   ‚ö†Ô∏è  Batch rectification failed: {e}")
            return {}

    def _rectify_invalid_variations_per_problem(self, problem_text: str, baseline_answer: str,
                                                 variations: List[Dict], invalid_indices: List[int]) -> List[Dict]:
        """
        Rectify invalid variations for ONE problem using baseline context.

        Args:
            problem_text: Original problem
            baseline_answer: Ground truth answer (for context)
            variations: All variations for this problem
            invalid_indices: Indices of invalid variations to correct

        Returns:
            Corrected variations for invalid indices (or None if correction failed)
        """
        if not invalid_indices:
            return []

        invalid_variations = [variations[i] for i in invalid_indices]

        logger.debug(f"      üîß Rectifying {len(invalid_indices)} invalid variations...")

        system_prompt = """You are an expert at fixing problem variations to preserve intent.

Your task: Fix invalid variations by applying MINIMAL corrections to preserve the original answer.

Key principles:
‚Ä¢ Fix ONLY the numerical values that broke the answer
‚Ä¢ Keep all other linguistic variations intact
‚Ä¢ The corrected variation should give the SAME answer as the baseline"""

        # Build correction prompt with baseline context
        variations_text = ""
        for i, var_idx in enumerate(invalid_indices):
            var = variations[var_idx]
            variations_text += f"\n{i+1}. Invalid Variation: {var['modified_problem']}\n"

        user_prompt = f"""Original Problem (BASELINE):
{problem_text}
Correct Answer: {baseline_answer}

Invalid Variations to fix:{variations_text}

For EACH invalid variation, provide a corrected version that gives the SAME answer as the baseline.

Format your response EXACTLY as:
1: <question>Corrected variation 1 here</question>
2: <question>Corrected variation 2 here</question>
...

Use <question></question> tags for each corrected variation."""

        try:
            # Use variation model for rectification (not judge model to avoid dual client initialization)
            model_client = self.model_client

            # Standard calling pattern (same as everywhere else)
            if hasattr(model_client, 'get_model_response'):
                responses = model_client.get_model_response([system_prompt], [user_prompt])
                response = responses[0] if responses else ""
            else:
                response = str(model_client.generate(user_prompt, system_prompt))

            # Parse corrected variations
            corrected = []
            response_text = str(response)

            for i in range(len(invalid_indices)):
                # Look for "i+1: <question>...</question>"
                pattern = f"{i+1}:.*?<question>(.*?)</question>"
                match = re.search(pattern, response_text, re.DOTALL)

                if match:
                    corrected_text = match.group(1).strip()
                    # Create corrected variation
                    corrected_var = invalid_variations[i].copy()
                    corrected_var['modified_problem'] = corrected_text
                    corrected.append(corrected_var)
                else:
                    corrected.append(None)

            success_count = sum(1 for c in corrected if c is not None)
            logger.debug(f"      ‚úÖ Corrected {success_count}/{len(invalid_indices)} variations")

            return corrected

        except Exception as e:
            logger.debug(f"      ‚ö†Ô∏è  Rectification failed: {e}")
            return [None] * len(invalid_indices)

    def _batch_validate_and_correct_variations(self, original_problem: str, variations: List[Dict], baseline_answer: str = None) -> List[Dict]:
        """
        Legacy wrapper: Validate and correct variations for a single problem.

        NOTE: For better performance, use _batch_validate_all_variations() + _rectify_invalid_variations_per_problem()
        across multiple problems at once.

        Process:
        1. Send all variations to model for validation (get flags for each)
        2. Identify indices of invalid variations
        3. Ask model to correct invalid ones (minimal changes to preserve intent)
        4. Replace invalid variations with corrected ones

        Args:
            original_problem: The original problem text
            variations: List of variation dicts with 'modified_problem' and 'candidates_transformed'

        Returns:
            List of validated/corrected variations (same structure as input)
        """
        if not variations:
            return variations

        logger.debug(f"        üîç Batch validating {len(variations)} variations...")

        # Step 1: Batch validate all variations
        system_prompt = """You are an expert at validating whether problem variations preserve the original intent and answer.

Your task: For each variation, determine if it has the EXACT SAME numerical answer as the original problem.

CRITICAL: Check if key numerical values changed:
‚Ä¢ Durations: 30 minutes ‚â† 45 minutes ‚â† 1 hour (must be EXACTLY equivalent)
‚Ä¢ Time points: 8:00 AM ‚â† noon ‚â† 2:00 PM ‚â† 14:00 (must be EXACTLY equivalent)
‚Ä¢ Quantities: 5 apples ‚â† 10 apples ‚â† 3 apples (must be EXACTLY the same count)
‚Ä¢ Distances: 60 miles ‚â† 100 miles (must be EXACTLY equivalent)

EXAMPLES OF INVALID CHANGES:
‚úó "30 minutes" ‚Üí "45 minutes" = INVALID (30 ‚â† 45)
‚úó "8:00 AM" ‚Üí "noon" = INVALID (8:00 AM ‚â† 12:00 PM)
‚úó "2 hours" ‚Üí "3 hours" = INVALID (2 ‚â† 3)

EXAMPLES OF VALID CHANGES:
‚úì "30 minutes" ‚Üí "half an hour" = VALID (30 min = 0.5 hours)
‚úì "8:00 AM" ‚Üí "0800 hours" = VALID (same time)
‚úì "2 hours" ‚Üí "120 minutes" = VALID (same duration)

If ANY key numerical value changed in a way that affects the answer, mark as INVALID."""

        # Build validation prompt with all variations
        variations_text = ""
        for i, var in enumerate(variations):
            # Handle both candidate-based and generic/persona variations
            if var.get('candidates_transformed'):
                candidates_str = ", ".join([f"'{c}'" for c in var['candidates_transformed']])
                variations_text += f"\n{i+1}. Variation: {var['modified_problem']}\n   Candidates varied: {candidates_str}\n"
            else:
                # For generic/persona variations, show transformation type
                trans_type = var.get('transformation_type', 'unknown')
                variations_text += f"\n{i+1}. Variation: {var['modified_problem']}\n   Transformation type: {trans_type}\n"

        user_prompt = f"""Original Problem:
{original_problem}

Variations to validate:{variations_text}

TASK: For EACH variation (1 to {len(variations)}), determine if the numerical answer would be THE SAME.

Check EVERY numerical value carefully:
- Did any duration change? (e.g., 30 min ‚Üí 45 min means different answer!)
- Did any time point change? (e.g., 8:00 AM ‚Üí noon means different answer!)
- Did any quantity change? (e.g., 5 ‚Üí 10 means different answer!)

Format your response EXACTLY as (one line per variation):
1: VALID
2: INVALID
3: VALID
...

BE STRICT: If you see ANY numerical value that changed to a different value (not just different format), mark as INVALID."""

        try:
            # Use variation model for validation (not judge model to avoid dual client initialization)
            model_client = self.model_client
            logger.debug(f"        üìã Using variation model for validation...")

            # Standard calling pattern (same as everywhere else)
            if hasattr(model_client, 'get_model_response'):
                responses = model_client.get_model_response([system_prompt], [user_prompt])
                response = responses[0] if responses else ""
            else:
                response = str(model_client.generate(user_prompt, system_prompt))

            # Parse validation flags
            logger.debug(f"        üìã Model validation response preview: {str(response)[:500]}...")

            validation_flags = []
            invalid_indices = []

            response_lines = str(response).strip().split('\n')
            parsed_count = 0

            for i in range(len(variations)):
                # Look for line starting with "i+1:" (e.g., "1:", "2:", etc.)
                found = False
                for line in response_lines:
                    line_upper = line.strip().upper()
                    # Check if this line is for variation i+1
                    if line_upper.startswith(f"{i+1}:"):
                        found = True
                        parsed_count += 1
                        # Check if it says INVALID
                        if 'INVALID' in line_upper:
                            validation_flags.append(False)
                            invalid_indices.append(i)
                            logger.debug(f"        ‚ùå Variation {i+1}: INVALID")
                        elif 'VALID' in line_upper:
                            validation_flags.append(True)
                            logger.debug(f"        ‚úì Variation {i+1}: VALID")
                        else:
                            # Unclear response - default to INVALID for safety
                            logger.debug(f"        ‚ö†Ô∏è  Variation {i+1}: Unclear response, marking as INVALID for safety")
                            validation_flags.append(False)
                            invalid_indices.append(i)
                        break

                if not found:
                    # Could not parse response for this variation - mark as INVALID for safety
                    logger.debug(f"        ‚ö†Ô∏è  Variation {i+1}: No response found, marking as INVALID for safety")
                    validation_flags.append(False)
                    invalid_indices.append(i)

            logger.debug(f"        üìä Parsed {parsed_count}/{len(variations)} validation responses")

            if not invalid_indices:
                logger.debug(f"        ‚úÖ All {len(variations)} variations are valid")
                return variations

            logger.debug(f"        ‚ö†Ô∏è  Found {len(invalid_indices)} invalid variations, correcting them...")

            # Step 2: Correct invalid variations
            corrected_variations = self._correct_invalid_variations(
                original_problem,
                [variations[i] for i in invalid_indices],
                invalid_indices
            )

            # Step 3: Replace invalid variations with corrected ones
            result_variations = variations.copy()
            for idx, corrected_var in zip(invalid_indices, corrected_variations):
                if corrected_var:  # Only replace if correction succeeded
                    result_variations[idx] = corrected_var
                else:
                    # If correction failed, keep original but mark it
                    logger.debug(f"        ‚ö†Ô∏è  Could not correct variation {idx+1}, keeping original")

            valid_count = sum(1 for i, v in enumerate(result_variations) if i not in invalid_indices or corrected_variations[invalid_indices.index(i)])
            logger.debug(f"        ‚úÖ Validation complete: {valid_count}/{len(variations)} variations valid/corrected")

            return result_variations

        except Exception as e:
            logger.debug(f"        ‚ö†Ô∏è  Batch validation failed: {e}, keeping all variations")
            import traceback
            traceback.print_exc()
            return variations

    def _correct_invalid_variations(self, original_problem: str, invalid_variations: List[Dict], indices: List[int]) -> List[Dict]:
        """
        Correct invalid variations by asking model to apply minimal changes.

        Args:
            original_problem: The original problem
            invalid_variations: List of invalid variation dicts
            indices: Original indices of these variations

        Returns:
            List of corrected variation dicts (or None if correction failed)
        """
        system_prompt = """You are an expert at fixing problem variations to preserve intent while maintaining linguistic diversity.

Your task: For each invalid variation, apply MINIMAL corrections to preserve the original answer.

Key principles:
‚Ä¢ Fix ONLY the parts that break the answer (wrong times, durations, values)
‚Ä¢ Keep all other linguistic variations intact
‚Ä¢ Preserve the transformation style (formal, informal, domain shift, etc.)
‚Ä¢ Make minimal changes - don't rewrite everything

Example:
ORIGINAL: "Be at work by 8:00 AM, 45 min to ready, 20 min drive, latest wake time?"
INVALID: "Be at office by noon, 45 min to ready, quarter hour commute, latest wake time?"
CORRECTED: "Be at office by 8:00 AM, 45 min to ready, quarter hour commute, latest wake time?"
           ‚Üí Only fixed "noon" ‚Üí "8:00 AM" (wrong time), kept other changes"""

        # Build correction prompt
        variations_text = ""
        for i, var in enumerate(invalid_variations):
            # Handle both candidate-based and generic/persona variations
            if var.get('candidates_transformed'):
                candidates_str = ", ".join([f"'{c}'" for c in var['candidates_transformed']])
                variations_text += f"\n{indices[i]+1}. Invalid Variation: {var['modified_problem']}\n   Candidates that should be varied: {candidates_str}\n"
            else:
                # For generic/persona variations
                trans_type = var.get('transformation_type', 'unknown')
                variations_text += f"\n{indices[i]+1}. Invalid Variation: {var['modified_problem']}\n   Transformation type: {trans_type}\n"

        user_prompt = f"""Original Problem:
{original_problem}

Invalid Variations to correct:{variations_text}

For EACH invalid variation, provide a corrected version that:
1. Preserves the SAME answer as the original
2. Keeps linguistic variations intact (formal/informal style, domain shifts, etc.)
3. Fixes ONLY the values that broke the answer (times, durations, quantities)

Format your response EXACTLY as:
{indices[0]+1}: <question>Your corrected variation here</question>
{"" if len(indices) < 2 else f"{indices[1]+1}: <question>Your corrected variation here</question>"}
{"..." if len(indices) > 2 else ""}

Use the <question></question> tags for each corrected variation."""

        try:
            # Use variation model for rectification (not judge model to avoid dual client initialization)
            model_client = self.model_client

            # Standard calling pattern (same as everywhere else)
            if hasattr(model_client, 'get_model_response'):
                responses = model_client.get_model_response([system_prompt], [user_prompt])
                response = responses[0] if responses else ""
            else:
                response = str(model_client.generate(user_prompt, system_prompt))

            # Parse corrected variations
            corrected = []
            response_text = str(response)

            for i, orig_var in enumerate(invalid_variations):
                # Try to extract corrected variation for this index
                idx_pattern = f"{indices[i]+1}:"
                if idx_pattern in response_text:
                    # Extract text after this index
                    start = response_text.find(idx_pattern) + len(idx_pattern)
                    # Find <question> tags
                    question_start = response_text.find("<question>", start)
                    question_end = response_text.find("</question>", start)

                    if question_start != -1 and question_end != -1:
                        corrected_text = response_text[question_start+10:question_end].strip()

                        # Create corrected variation dict
                        corrected_var = orig_var.copy()
                        corrected_var['modified_problem'] = corrected_text
                        corrected.append(corrected_var)
                    else:
                        corrected.append(None)
                else:
                    corrected.append(None)

            return corrected

        except Exception as e:
            logger.debug(f"        ‚ö†Ô∏è  Correction failed: {e}")
            return [None] * len(invalid_variations)

    def _extract_variation_from_response(self, response: str) -> str:
        """
        Extract variation from model response with robust parsing.

        Expected format: <question>Your varied question here</question>

        Tries strict matching first, then falls back to extracting from within tags
        if extra commentary is present.

        Returns: Cleaned variation text or None if format not matched
        """
        if not response or not response.strip():
            return None

        response = response.strip()

        # STRICT: Must start with <question> and end with </question>
        # Allow whitespace before/after but nothing else
        strict_match = re.match(r'^\s*<question>\s*(.*?)\s*</question>\s*$', response, re.DOTALL | re.IGNORECASE)

        if strict_match:
            candidate = strict_match.group(1).strip()
            cleaned = clean_model_response(candidate)

            if cleaned and is_valid_question(cleaned):
                return cleaned
            else:
                # Tags present but content invalid
                logger.debug(f"          ‚ö†Ô∏è  Tags found but content validation failed")
                return None

        # FALLBACK: Extract from anywhere in response if strict match fails
        # This handles cases where model adds commentary/explanation
        relaxed_match = re.search(r'<question>\s*(.*?)\s*</question>', response, re.DOTALL | re.IGNORECASE)

        if relaxed_match:
            candidate = relaxed_match.group(1).strip()
            cleaned = clean_model_response(candidate)

            if cleaned and is_valid_question(cleaned):
                logger.debug(f"          ‚ö†Ô∏è  Extracted question from response with extra text (model added commentary)")
                return cleaned
            else:
                logger.debug(f"          ‚ùå Tags found but extracted content validation failed")
                return None

        # No valid tags found
        logger.debug(f"          ‚ùå Response missing required <question> tags - REJECTING")
        return None

    def _create_bucket_variations_batched(self, problem: str, selected_combinations: List[Dict], candidate_buckets: Dict) -> List[Dict]:
        """Create final variations using BATCHED model calls for efficiency."""
        logger.debug(f"    üöÄ BATCHING final variation creation for {len(selected_combinations)} combinations...")
        
        variations = []
        
        # Prepare all prompts for batching
        system_prompts = []
        user_prompts = []
        combination_lookup = []  # Track which combination each prompt corresponds to
        transformation_details_lookup = []
        
        for combo_data in selected_combinations:
            import random
            candidates = combo_data['candidates']
            
            # Generate random selection from buckets for this combination
            selected_transformations = {}
            transformation_details = []
            
            for candidate in candidates:
                candidate_text = candidate['text']
                if candidate_text in candidate_buckets and candidate_buckets[candidate_text]:
                    selected_transformation = random.choice(candidate_buckets[candidate_text])
                    selected_transformations[candidate_text] = selected_transformation
                    transformation_details.append(f"'{candidate_text}' ‚Üí '{selected_transformation}'")
                else:
                    selected_transformations[candidate_text] = candidate_text
                    transformation_details.append(f"'{candidate_text}' ‚Üí '{candidate_text}' (fallback)")
            
            # Include domain-specific static patterns as guidance
            static_guidance = self._get_static_guidance_for_combination(candidates)
            
            system_prompt = f"""You are an expert at creating meaningful question variations by transforming multiple candidates simultaneously.

CRITICAL REQUIREMENTS:
1. PRESERVE exact numerical answer and question intent
2. USE EXACTLY the specified transformations provided
3. TRANSFORM all specified candidates using the given transformations
4. ENSURE mathematical/logical validity
5. Use PLAIN TEXT only - no formatting

{static_guidance}

ABSOLUTELY FORBIDDEN:
‚úó Identity transformations: "apple" ‚Üí "apple" (same-to-same is NOT a transformation)
‚úó Changing core question logic or numerical answer
‚úó Modifying transformations that were provided
‚úó Changing problem structure or intent

QUALITY EXAMPLES OF COMPLETE TRANSFORMATIONS:

Example 1 (Math word problem):
Original: "A car travels 60 miles in 2 hours. What is its speed?"
Transformations: "60" ‚Üí "sixty" | "miles" ‚Üí "mi" | "2 hours" ‚Üí "120 minutes"
‚úì GOOD: "A car travels sixty mi in 120 minutes. What is its speed?"
‚úó BAD: "A vehicle goes 60 miles in 2 hours. What's the velocity?" (changed core logic)

Example 2 (Temporal problem):
Original: "Meeting starts at 3:00 PM and lasts 90 minutes. When does it end?"
Transformations: "3:00 PM" ‚Üí "fifteen hundred hours" | "90 minutes" ‚Üí "one and a half hours"
‚úì GOOD: "Meeting starts at fifteen hundred hours and lasts one and a half hours. When does it end?"
‚úó BAD: "Session begins at 3:00 PM lasting 90 minutes. What's the conclusion time?" (changed wording beyond transformations)

Example 3 (Mixed domains):
Original: "John walks 3/4 of a mile in 15 minutes. How fast does he walk?"
Transformations: "John" ‚Üí "a person" | "walks" ‚Üí "travels on foot" | "3/4" ‚Üí "three quarters"
‚úì GOOD: "A person travels on foot three quarters of a mile in 15 minutes. How fast does he walk?"
‚úó BAD: "John walks 3/4 mile in 15 mins. What's his pace?" (didn't use exact transformations)

OUTPUT FORMAT: Return ONLY the modified question wrapped in <question> tags.
Example: <question>Your modified question here</question>"""

            user_prompt = f"""Original: {problem}

Apply these EXACT transformations:
{chr(10).join(transformation_details)}

Create ONE variation using EXACTLY the specified transformations while preserving exact answer and intent."""

            system_prompts.append(system_prompt)
            user_prompts.append(user_prompt)
            combination_lookup.append(combo_data)
            transformation_details_lookup.append((selected_transformations, transformation_details))
        
        # BATCH CALL: Process all combinations at once
        try:
            logger.debug(f"        üì¶ Batching {len(selected_combinations)} variation creation prompts...")
            if hasattr(self.model_client, 'get_model_response'):
                responses = self.model_client.get_model_response(system_prompts, user_prompts)
            else:
                # Fallback for non-batching clients
                responses = []
                for i, (sys_prompt, user_prompt) in enumerate(zip(system_prompts, user_prompts)):
                    response = str(self.model_client.generate(user_prompt, sys_prompt))
                    responses.append(response)
            
            # Process all responses
            for i, (response, combo_data, (selected_transformations, transformation_details)) in enumerate(
                zip(responses, combination_lookup, transformation_details_lookup)):
                
                candidates = combo_data['candidates']
                
                # Extract question from tags
                question_match = re.search(r'<question>(.*?)</question>', response, re.DOTALL)
                if question_match:
                    cleaned = clean_model_response(question_match.group(1).strip())
                    
                    if cleaned and is_valid_question(cleaned):
                        variation = {
                            'original_problem': problem,
                            'modified_problem': cleaned,
                            'transformation_type': f'bucket_combination_{combo_data["size"]}way',
                            'candidates_transformed': [c['text'] for c in candidates],
                            'selected_variants': selected_transformations,
                            'transformation_details': transformation_details,
                            'combination_size': combo_data['size'],
                            'domains_involved': list(set(c['domain'] for c in combo_data['candidates'])),
                            'cross_domain': len(set(c['domain'] for c in combo_data['candidates'])) > 1,
                            'confidence': 'model_generated'
                        }
                        variations.append(variation)
                        logger.debug(f"          ‚úì Generated variation {i+1}/{len(selected_combinations)}")
                    else:
                        logger.debug(f"          ‚ùå Invalid variation {i+1}/{len(selected_combinations)}")
                else:
                    logger.debug(f"          ‚ùå Failed to parse variation {i+1}/{len(selected_combinations)}")
                    
        except Exception as e:
            logger.debug(f"        ‚ùå Batch processing failed: {e}")
            # Fallback to individual processing
            return self._create_bucket_variations_individual(problem, selected_combinations, candidate_buckets)
        
        logger.debug(f"    ‚úÖ Batch completed: {len(variations)} variations generated")
        return variations
    
    def _create_bucket_variations_individual(self, problem: str, selected_combinations: List[Dict], candidate_buckets: Dict) -> List[Dict]:
        """Fallback: Create variations individually if batching fails."""
        logger.debug(f"    ‚Ü© Falling back to individual variation creation...")
        variations = []
        
        for combo_data in selected_combinations:
            variation = self._create_bucket_variation(problem, combo_data, candidate_buckets)
            if variation:
                variations.append(variation)
        
        return variations
    
    def _generate_candidate_buckets(self, problem: str, candidates: List[Dict]) -> Dict:
        """Generate variant buckets for each candidate using BATCHED model calls."""
        logger.debug(f"      üöÄ BATCHING candidate variation generation for {len(candidates)} candidates...")
        
        buckets = {}
        variants_per_candidate = 4
        
        # Prepare all prompts for batching
        system_prompts = []
        user_prompts = []
        candidate_lookup = []  # Track which candidate each prompt corresponds to
        
        for candidate in candidates:
            # Show exactly where in the question this element will be replaced
            highlighted_question = problem.replace(candidate['text'], f"‚Üí‚Üí‚Üí{candidate['text']}‚Üê‚Üê‚Üê")

            # Get domain-specific patterns for this candidate
            candidate_guidance = self._get_static_guidance_for_combination([candidate])

            system_prompt = f"""You are an expert at generating contextually-appropriate alternative representations that will be substituted in place of specific elements in questions.

CRITICAL TASK: Generate {variants_per_candidate} different alternatives for the marked element that will be substituted IN-PLACE in the original question.

üö® SUBSTITUTION TEST: Each variant must make sense when replacing the original element in context.

SUBSTITUTION EXAMPLES:
Original: "Find 3/4 of 20"
‚úì CORRECT: "3/4" ‚Üí "0.75" gives "Find 0.75 of 20" (same answer: 15)
‚ùå INCORRECT: "3/4" ‚Üí "three quarters of a pizza" gives "Find three quarters of a pizza of 20" (breaks meaning)

{candidate_guidance}

üîç PATTERN-GUIDED GENERATION STRATEGY:
1. üìã CAREFULLY EXAMINE the transformation patterns provided above for your candidate's domain ({candidate['domain']})
2. üéØ IDENTIFY which patterns are MOST RELEVANT to your specific candidate element
3. üß† THINK about what types of variations would provide COMPLEX COVERAGE and test different cognitive aspects
4. ‚ú® APPLY the relevant pattern types to generate sophisticated alternatives that go beyond simple synonyms
5. üîÑ ENSURE each variant represents a DIFFERENT type of transformation (format, structure, register, notation, etc.)

ESSENTIAL REQUIREMENTS:
1. ‚úÖ PRESERVE exact meaning, numerical value, and format appropriateness
2. ‚úÖ ENSURE the substituted question remains grammatically correct and coherent
3. ‚úÖ MAINTAIN the same answer and logical structure
4. ‚úÖ RESPECT compositional units (don't break apart formats like "H:M:S", "X hours Y minutes")
5. ‚úÖ Use appropriate register for the question context

DIVERSITY & COMPLEXITY GUIDELINES:
üéØ CREATE meaningful, diverse alternatives (not trivial changes)
üéØ Each variant should be SUBSTANTIALLY DIFFERENT from others in:
   - Word choice and phrasing style
   - Level of formality (formal/informal/technical)
   - Complexity level (simple/detailed/descriptive)
   - Representation format (numeric/textual/abbreviated)
   - Structural pattern type (use the patterns above as inspiration)
üéØ Ensure variants are NOT too similar to one another
üéØ LEVERAGE PATTERN EXAMPLES: Use the domain-specific transformation patterns above to generate MORE SOPHISTICATED variations
üéØ DOMAIN-SPECIFIC DIVERSITY:
   ‚Ä¢ Mathematical elements: Use word forms, different notations, descriptive phrases, structural equivalents
   ‚Ä¢ Temporal elements: Use different time formats, descriptive phrases, relative expressions, conversion patterns
   ‚Ä¢ Linguistic elements: Use synonyms, descriptive phrases, formal/informal variants, grammatical transformations
   ‚Ä¢ Format specifiers: Use equivalent format descriptions, technical/plain language

SUBSTITUTION-AWARE EXAMPLES:
Original: "It takes 2 hours to complete the task"
Element: "2 hours"
Good variants: ["120 minutes", "two hours", "2 hr", "a couple of hours"]
‚ùå Bad: ["one hundred twenty minutes and forty five seconds per wall times four"] (changes meaning/context)

Original: "Answer in H:M:S format"
Element: "H:M:S"
Good variants: ["hours:minutes:seconds", "HH:MM:SS", "time format", "hour:minute:second"]
‚ùå Bad: ["nine hours forty three minutes"] (changes from format to specific time)

CONTEXT-AWARE GENERATION STRATEGY:
1. Consider what grammatical role the element plays in the sentence
2. Ensure numerical consistency with the problem's mathematical structure
3. Maintain the same level of specificity/generality
4. Keep format indicators as format indicators, not specific values
5. Preserve temporal/mathematical relationships

OUTPUT FORMAT: Return exactly {variants_per_candidate} variants, one per line:
<variants>
variant 1
variant 2
variant 3
variant 4
</variants>"""

            user_prompt = f"""ORIGINAL QUESTION: {problem}
HIGHLIGHTED CONTEXT: {highlighted_question}
ELEMENT TO VARY: "{candidate['text']}"
ELEMENT TYPE: {candidate['domain']} - {candidate['topic']}

üéØ TASK: Generate {variants_per_candidate} alternatives that can be substituted IN-PLACE without changing:
- The question's core meaning
- The mathematical/logical structure
- The expected answer type
- Grammatical correctness

üîç SUBSTITUTION CHECK: Read each variant in context to ensure it makes sense.

REQUIREMENTS FOR THIS ELEMENT:
1. Maintain exact semantic meaning
2. Preserve numerical accuracy if applicable
3. Keep appropriate grammatical form for the sentence
4. Consider the mathematical/temporal domain of the problem
5. Ensure each variant is contextually appropriate

Generate {variants_per_candidate} high-quality alternatives optimized for in-place substitution."""

            system_prompts.append(system_prompt)
            user_prompts.append(user_prompt)
            candidate_lookup.append(candidate)
        
        # BATCH CALL: Process all candidates at once
        try:
            logger.debug(f"        üì¶ Batching {len(candidates)} prompts...")
            if hasattr(self.model_client, 'get_model_response'):
                responses = self.model_client.get_model_response(system_prompts, user_prompts)
            else:
                # Fallback for non-batching clients
                responses = []
                for i, (sys_prompt, user_prompt) in enumerate(zip(system_prompts, user_prompts)):
                    response = str(self.model_client.generate(user_prompt, sys_prompt))
                    responses.append(response)
            
            # Process all responses
            for i, (response, candidate) in enumerate(zip(responses, candidate_lookup)):
                logger.debug(f"        Processing variants for '{candidate['text']}'...")
                
                # Extract and validate variants
                variants_match = re.search(r'<variants>(.*?)</variants>', response, re.DOTALL)
                if variants_match:
                    variant_lines = variants_match.group(1).strip().split('\n')
                    raw_variants = [line.strip() for line in variant_lines if line.strip()]
                    
                    # Validate variants for quality and diversity
                    validated_variants = self._validate_candidate_variants(candidate['text'], raw_variants)
                    
                    if validated_variants and len(validated_variants) >= 2:
                        buckets[candidate['text']] = validated_variants
                        logger.debug(f"          ‚úì {len(validated_variants)} validated variants")
                    else:
                        # Use fallback variants
                        fallback_variants = self._generate_fallback_variants(candidate)
                        buckets[candidate['text']] = fallback_variants
                        logger.debug(f"          ‚Ü© {len(fallback_variants)} fallback variants")
                else:
                    fallback_variants = self._generate_fallback_variants(candidate)
                    buckets[candidate['text']] = fallback_variants
                    logger.debug(f"          ‚Ü© {len(fallback_variants)} fallback variants")
                    
        except Exception as e:
            logger.debug(f"        ‚ùå Batch processing failed: {e}")
            # Fallback to individual processing
            return self._generate_candidate_buckets_individual(problem, candidates)
        
        logger.debug(f"      ‚úÖ Batch completed: {len(buckets)} candidate buckets generated")
        return buckets
    
    def _generate_candidate_buckets_individual(self, problem: str, candidates: List[Dict]) -> Dict:
        """Fallback: Generate buckets individually if batching fails."""
        logger.debug(f"      ‚Ü© Falling back to individual candidate processing...")
        buckets = {}
        
        for candidate in candidates:
            logger.debug(f"        Individual processing for '{candidate['text']}'...")
            # Use fallback variants for simplicity
            fallback_variants = self._generate_fallback_variants(candidate)
            buckets[candidate['text']] = fallback_variants
        
        return buckets
    
    def _validate_candidate_variants(self, original: str, variants: List[str]) -> List[str]:
        """Validate candidate variants for quality, completeness, and diversity."""
        validated = []
        
        for variant in variants:
            # Basic quality checks
            if (len(variant.strip()) > 0 and  # Not empty
                variant.strip() != original and  # Different from original
                len(variant.split()) <= 10 and  # Not too verbose
                not any(char in variant for char in ['<', '>', '{', '}', '*', '#']) and  # No formatting
                variant.replace(original, '').strip() != '' and  # Not just wrapped original
                self._is_english_text(variant)):  # English only
                validated.append(variant.strip())
        
        # Remove near-duplicates
        final_variants = []
        for variant in validated:
            if not any(self._are_too_similar(variant, existing) for existing in final_variants):
                final_variants.append(variant)
        
        return final_variants[:4]  # Max 4 variants
    
    def _is_english_text(self, text: str) -> bool:
        """Check if text is primarily in English."""
        # Simple heuristic: check for common English patterns
        english_patterns = [
            r'\b(the|and|or|a|an|in|on|at|to|for|of|with|by)\b',
            r'\d+',  # Numbers are universal
            r'[a-zA-Z]+'  # Latin alphabet
        ]
        
        for pattern in english_patterns:
            if re.search(pattern, text, re.IGNORECASE):
                return True
        return len(text.split()) <= 3  # Short phrases are probably OK
    
    def _are_too_similar(self, text1: str, text2: str) -> bool:
        """Check if two variants are too similar."""
        words1 = set(text1.lower().split())
        words2 = set(text2.lower().split())
        
        if len(words1) == 0 or len(words2) == 0:
            return False
            
        # Calculate Jaccard similarity
        intersection = len(words1.intersection(words2))
        union = len(words1.union(words2))
        similarity = intersection / union if union > 0 else 0
        
        return similarity > 0.7  # Too similar if >70% overlap
    
    def _generate_fallback_variants(self, candidate: Dict) -> List[str]:
        """Generate fallback variants when model fails."""
        text = candidate['text']
        domain = candidate['domain']
        topic = candidate['topic']
        
        variants = [text]  # Always include original
        
        # Domain-specific fallback patterns
        if domain == 'math' and topic == 'number':
            if text.isdigit():
                num = int(text)
                if num <= 20:
                    word_form = self._number_to_words(num)
                    if word_form != text:
                        variants.append(word_form)
                variants.append(f"the number {text}")
                variants.append(f"a value of {text}")
        
        elif domain == 'temporal' and 'hour' in text:
            variants.append(f"a duration of {text}")
            variants.append(f"the time span of {text}")
        
        elif domain == 'nl' and topic == 'action':
            variants.append(f"the action of {text}")
            if text.lower() == 'calculate':
                variants.extend(['determine', 'find', 'compute'])
        
        return list(set(variants))  # Remove duplicates
    
    def _get_domain_specific_variation_guidance(self, candidate: Dict) -> str:
        """Get domain-specific guidance for variant generation."""
        domain = candidate['domain']
        topic = candidate['topic']
        
        if domain == 'math':
            return """
MATHEMATICAL VARIATION EXAMPLES:
‚Ä¢ Numbers: "15" ‚Üí ["fifteen", "the number 15", "a value of 15", "15 units"]
‚Ä¢ Fractions: "3/4" ‚Üí ["three quarters", "three-fourths", "0.75", "three divided by four"]
‚Ä¢ Geometry: "rectangle" ‚Üí ["quadrilateral", "four-sided figure", "rectangular shape", "right-angled parallelogram"]
‚Ä¢ Units: "cm" ‚Üí ["centimeters", "centimeter units", "cm measurement", "metric length units"]"""
            
        elif domain == 'temporal':
            return """
TEMPORAL VARIATION EXAMPLES:
‚Ä¢ Time: "3:00 PM" ‚Üí ["fifteen hundred hours", "three in the afternoon", "3 o'clock PM", "three in the afternoon"]
‚Ä¢ Duration: "2 hours" ‚Üí ["120 minutes", "two hours", "a span of 2 hours", "7200 seconds"]
‚Ä¢ Days: "Monday" ‚Üí ["the first day of the week", "start of the week", "the day Monday", "beginning of the work week"]"""
            
        elif domain == 'nl':
            return """
LINGUISTIC VARIATION EXAMPLES:
‚Ä¢ Actions: "calculate" ‚Üí ["determine", "find", "compute", "work out"]
‚Ä¢ Objects: "area" ‚Üí ["surface space", "two-dimensional space", "spatial extent", "region size"]  
‚Ä¢ People: "John" ‚Üí ["a person named John", "an individual named John", "someone called John", "John (the person)"]"""
        
        return "Generate diverse representations using different styles and formats."
    
    def _calculate_exhaustive_combinations(self, candidates: List[Dict]) -> List[Dict]:
        """Calculate all possible combinations exhaustively."""
        from itertools import combinations as iter_combinations
        
        all_combinations = []
        
        # Generate combinations of different sizes (2-way to 5-way max)
        max_size = min(len(candidates), 5)
        for size in range(2, max_size + 1):
            for combo in iter_combinations(candidates, size):
                domains = set(c['domain'] for c in combo)
                all_combinations.append({
                    'candidates': list(combo),
                    'size': size,
                    'domains': list(domains),
                    'cross_domain': len(domains) > 1
                })
        
        return all_combinations

    def _filter_position_overlaps(self, candidates: List[Dict]) -> List[Dict]:
        """
        Filter out position-overlapping candidates within a combination.
        Keeps higher-priority candidates (fragments, composites) over lower-priority ones.

        Args:
            candidates: List of candidate dicts with 'text', 'pos', 'domain', etc.

        Returns:
            Filtered list with no position overlaps
        """
        if len(candidates) <= 1:
            return candidates

        # Create list with position ranges and priorities
        candidates_with_ranges = []
        for cand in candidates:
            start_pos = cand.get('pos', -1)
            if start_pos == -1:
                # Can't determine position, keep it but warn
                logger.debug(f"        ‚ö†Ô∏è Candidate '{cand['text']}' has no position, keeping it")
                candidates_with_ranges.append((cand, -1, -1, 0))  # Unknown position
                continue

            end_pos = start_pos + len(cand['text'])

            # Calculate priority:
            # 1. Fragments with high priority get highest score
            # 2. Longer candidates (composites) get higher score
            # 3. Domain-specific priorities
            priority = len(cand['text'])  # Base: length

            if cand.get('domain') == 'fragment':
                fragment_priority = cand.get('fragment_priority', 1.0)
                priority += fragment_priority * 100  # Fragments get big boost

            candidates_with_ranges.append((cand, start_pos, end_pos, priority))

        # Sort by priority (descending) - highest priority first
        candidates_with_ranges.sort(key=lambda x: x[3], reverse=True)

        # Filter overlaps: keep higher-priority candidates
        filtered = []
        used_ranges = []

        for cand, start_pos, end_pos, priority in candidates_with_ranges:
            # Skip unknown positions (we'll keep them)
            if start_pos == -1:
                filtered.append(cand)
                continue

            # Check if this overlaps with any already-kept candidate
            overlap = False
            for used_start, used_end in used_ranges:
                if not (end_pos <= used_start or start_pos >= used_end):  # Overlap detected
                    overlap = True
                    logger.debug(f"        üîπ Filtered overlap: '{cand['text']}' (pos {start_pos}-{end_pos}) overlaps with existing range {used_start}-{used_end}")
                    break

            if not overlap:
                filtered.append(cand)
                used_ranges.append((start_pos, end_pos))

        if len(filtered) < len(candidates):
            logger.debug(f"        ‚úÖ Position overlap filter: {len(candidates)} ‚Üí {len(filtered)} candidates (removed {len(candidates) - len(filtered)} overlaps)")

        return filtered

    def _model_select_diverse_combinations(self, problem: str, candidates: List[Dict], max_combinations: int) -> List[Dict]:
        """Ask model to select diverse, non-overlapping combinations of different sizes."""

        candidate_list = []
        for i, cand in enumerate(candidates):
            # Include fragment marker and priority if present
            domain_info = cand['domain']
            if cand['domain'] == 'fragment':
                priority = cand.get('fragment_priority', 1.0)
                domain_info = f"fragment(priority:{priority})"
            candidate_list.append(f"[{i}] '{cand['text']}' (domain:{domain_info}, topic:{cand['topic']})")

        system_prompt = f"""You are an expert at identifying impactful combinations of candidates for creating varied question transformations.

TASK: Identify and rank the most IMPACTFUL combinations that bring maximum variation to the problem.
Return combinations in order of impact (most impactful first).

IMPACT CRITERIA:
1. Testing different cognitive capabilities (reasoning, memory, computation, etc.)
2. Cross-domain diversity (math+temporal, nl+math, fragment+candidates, etc.)
3. Semantic richness (varying key problem elements that change interpretation)
4. Coverage (different aspects of the problem across all combinations)

üîπ SIZE DIVERSITY (Adaptive to this problem):
‚Ä¢ LARGE: Maximum possible components that have MOST IMPACT for this problem
  - Not just max count, but max impactful components
  - Focus on high-priority fragments and key candidates
‚Ä¢ MEDIUM: ~Half of large size
‚Ä¢ SMALL: From medium size down to 1

Include a MIX of sizes across all combinations for diversity.

üîπ FRAGMENT & POSITION OVERLAP RULES (CRITICAL):
‚Ä¢ Fragments (domain='fragment') are semantic units like "60 miles per hour", "3 apples for $5"
‚Ä¢ Some candidates may be PARTS of fragments (e.g., "60" is inside "60 miles per hour")
‚Ä¢ This overlap is FINE in the candidate list
‚Ä¢ BUT within a SINGLE combination, avoid selecting BOTH:
  - A fragment AND the individual candidates it contains
  ‚úì GOOD: Select [fragment:"60 miles per hour"] OR [candidate:"60", candidate:"miles"]
  ‚úó BAD: Select [fragment:"60 miles per hour", candidate:"60"] - same position varied twice!
‚Ä¢ PREFER high-priority fragments (priority > 1.5) over their component candidates
‚Ä¢ Each position in the problem should only be varied ONCE per combination

CRITICAL OUTPUT FORMAT: Use this ULTRA-COMPACT format to minimize tokens:
0,2,4,6|1,3|5,7,8|1,4
Rules:
- Each combination = comma-separated indices
- Different combinations = separated by |
- 0-based indexing
- Most impactful combinations FIRST
- NO JSON, NO brackets, NO extra text
- Example: "0,1,3|2,4|0,5,6,7" means 3 combinations: [0,1,3], [2,4], [0,5,6,7]"""

        user_prompt = f"""Problem: {problem}

Available candidates ({len(candidates)} total):
{chr(10).join(candidate_list)}

TASK: Generate impactful combinations ranked by impact (most impactful first).

GUIDELINES:
- You have {len(candidates)} candidates available
- Identify combinations that bring MAXIMUM VARIATION to the problem
- Include a MIX of sizes: large (max impactful), medium (~half), small (1 to medium)
- Prioritize high-priority fragments and cross-domain combinations
- Ensure no position overlap within each combination
- Return combinations in order of impact

Respond with indices only in format: 0,2,4|1,3|5,7

Generate impactful combinations ranked by impact. I will select the top combinations I need.

CRITICAL: You must respond with ONLY combination indices in ultra-compact format.
Example: 0,2,4|1,3|5,7
DO NOT include any other text, numbers, or explanations. Only the index combinations."""

        try:
            if hasattr(self.model_client, 'get_model_response'):
                responses = self.model_client.get_model_response([system_prompt], [user_prompt])
                response = responses[0] if responses else ""
            else:
                response = str(self.model_client.generate(user_prompt, system_prompt))
            
            selected_combinations = []
            # Clean response - remove common wrapper text
            clean_response = response.strip()
            for unwrap_pattern in [r'```[^`]*```', r'<[^>]*>', r'"([^"]*)"']:
                match = re.search(unwrap_pattern, clean_response)
                if match:
                    clean_response = match.group(1) if match.groups() else match.group(0)
                    break
            # Extract compact format: look for pattern like "0,1,3|2,4|5,6,7"
            compact_patterns = [
                r'(\d+(?:,\d+)*(?:\|\d+(?:,\d+)*)*)',  # Primary pattern
                r'([0-9,|]+)',                          # Fallback: any digits, commas, pipes
            ]
            combinations_text = None
            for pattern in compact_patterns:
                match = re.search(pattern, clean_response)
                if match:
                    combinations_text = match.group(1)
                    logger.debug(f"        ‚úÖ Found compact format: '{combinations_text}'")
                    break
            if combinations_text:
                try:
                    # Split by | to get individual combinations
                    combo_strings = combinations_text.split('|')
                    for combo_str in combo_strings:
                        combo_str = combo_str.strip()
                        if not combo_str:
                            continue
                        try:
                            # Parse comma-separated indices
                            indices = [int(x.strip()) for x in combo_str.split(',')]
                            # Validate indices
                            if all(0 <= idx < len(candidates) for idx in indices) and len(indices) > 0:
                                combo_candidates = [candidates[i] for i in indices]

                                # ‚úÖ POSITION OVERLAP CHECK: Remove overlapping candidates within this combination
                                combo_candidates = self._filter_position_overlaps(combo_candidates)

                                if combo_candidates:  # Only add if we have candidates left after filtering
                                    selected_combinations.append({
                                        'candidates': combo_candidates,
                                        'reason': f'Model-selected diverse {len(combo_candidates)}-way combination',
                                        'size': len(combo_candidates),
                                        'priority': 100  # High priority for model selections
                                    })
                                else:
                                    logger.debug(f"        ‚ö†Ô∏è Combination '{combo_str}' had complete position overlap, skipped")
                            else:
                                logger.debug(f"        ‚ö†Ô∏è Invalid indices in '{combo_str}': {indices} (max valid index: {len(candidates)-1})")
                        except ValueError as e:
                            logger.debug(f"        ‚ö†Ô∏è Failed to parse combination '{combo_str}': {e}")
                            continue
                except Exception as e:
                    logger.debug(f"        ‚ö†Ô∏è Error processing combinations: {e}")
            else:
                logger.debug(f"        ‚ö†Ô∏è Failed to parse compact format from: '{clean_response}'")

            # Take top max_combinations from the ranked list (model returns by impact, we take the top N)
            if selected_combinations:
                result = selected_combinations[:max_combinations]
                sizes = [c['size'] for c in result]
                logger.debug(f"    ‚úÖ Selected top {len(result)} combinations by impact (sizes: {sizes})")
                return result

            # Fallback: select diverse combinations manually
            logger.debug(f"        ‚ö†Ô∏è Model selection failed, using fallback")
            return self._fallback_diverse_combinations(candidates, max_combinations)
            
        except Exception as e:
            logger.debug(f"        ‚ö†Ô∏è Model selection failed: {e}")
            return self._fallback_diverse_combinations(candidates, max_combinations)
    
    def _create_bucket_variation(self, problem: str, combo_data: Dict, candidate_buckets: Dict) -> Dict:
        """Create variation using random selection from candidate buckets."""
        import random
        
        candidates = combo_data['candidates']
        
        # Randomly select one variant from each candidate's bucket
        selected_variants = {}
        transformation_details = []
        
        for candidate in candidates:
            bucket = candidate_buckets.get(candidate['text'], [candidate['text']])
            selected_variant = random.choice(bucket)
            selected_variants[candidate['text']] = selected_variant
            transformation_details.append(f"'{candidate['text']}' ‚Üí '{selected_variant}'")
        
        # Create the final variation by applying all transformations using position-based replacement
        modified_problem = self._apply_position_based_replacements(problem, candidates, selected_variants)
        
        # Validate the result
        if is_valid_question(modified_problem):
            return {
                'original_problem': problem,
                'modified_problem': modified_problem,
                'transformation_type': f'bucket_combination_{combo_data["size"]}way',
                'candidates_transformed': [c['text'] for c in candidates],
                'selected_variants': selected_variants,
                'transformation_details': transformation_details,
                'combination_size': combo_data['size'],
                'domains_involved': list(set(c['domain'] for c in combo_data['candidates'])),
                'cross_domain': len(set(c['domain'] for c in combo_data['candidates'])) > 1,
                'confidence': 'model_generated'
            }
        
        return None
    
    def _get_prioritized_combinations(self, problem: str, candidates: List[Dict], 
                                    max_combinations: int) -> List[Dict]:
        """Create smart candidate combinations prioritizing larger cross-domain combinations."""
        
        logger.debug(f"    Creating smart combinations from {len(candidates)} candidates")
        
        combinations = []
        
        # Start with largest combinations and work down
        for size in [5, 4, 3, 2]:
            if len(candidates) >= size:
                from itertools import combinations as iter_combinations
                
                # Generate all combinations of this size
                for combo in iter_combinations(candidates, size):
                    # Prefer cross-domain combinations
                    domains = set(c['domain'] for c in combo)
                    if len(domains) > 1:  # Cross-domain preferred
                        priority_score = len(domains) * 10 + size
                        reason = f"Cross-domain {size}-way combination: {', '.join(domains)}"
                    else:
                        priority_score = size
                        reason = f"Single-domain {size}-way combination: {list(domains)[0]}"
                    
                    combinations.append({
                        'candidates': list(combo),
                        'reason': reason,
                        'size': size,
                        'priority': priority_score
                    })
        
        # Sort by priority (cross-domain and larger combinations first)
        combinations.sort(key=lambda x: x['priority'], reverse=True)
        
        # Return top combinations
        result = combinations[:max_combinations]
        logger.debug(f"    Selected {len(result)} combinations (sizes: {[c['size'] for c in result]})")
        return result
    
    
    def _fallback_diverse_combinations(self, candidates: List[Dict], max_combinations: int) -> List[Dict]:
        """
        Create diverse combinations manually when model fails.
        Strategy: Generate varied-size combinations (large, medium, small) and return top max_combinations.
        """
        combinations = []
        total_candidates = len(candidates)

        if total_candidates == 0:
            return []

        # Define adaptive size categories based on available candidates
        large_size = total_candidates  # Maximum impactful for this problem
        medium_size = max(1, large_size // 2)  # Half of large
        # Small ranges from medium down to 1

        # Group candidates by domain for cross-domain combinations
        domains = {}
        for i, cand in enumerate(candidates):
            domain = cand['domain']
            if domain not in domains:
                domains[domain] = []
            domains[domain].append(i)

        domain_items = list(domains.items())
        used_combinations = set()  # Track to avoid duplicates

        # Generate combinations with varied sizes
        # We'll generate MORE than needed and take top max_combinations
        target_generate = max_combinations * 2  # Generate 2x to have choices

        for combo_num in range(target_generate):
            # Cycle through sizes: large, medium, small
            if combo_num % 3 == 0:
                # Large combination (cross-domain, max diversity)
                combo_indices = []
                if domain_items:
                    candidates_per_domain = large_size // len(domain_items)
                    for domain, indices in domain_items:
                        available = [idx for idx in indices if idx not in combo_indices]
                        take = min(len(available), candidates_per_domain)
                        combo_indices.extend(available[:take])
                        if len(combo_indices) >= large_size:
                            break
            elif combo_num % 3 == 1:
                # Medium combination
                combo_indices = list(range(total_candidates))[combo_num % total_candidates:][:medium_size]
            else:
                # Small combination (1 to medium size)
                small_size = 1 + (combo_num % medium_size)
                combo_indices = list(range(total_candidates))[combo_num % total_candidates:][:small_size]

            # Filter position overlaps
            combo_candidates = [candidates[i] for i in combo_indices if i < total_candidates]
            combo_candidates = self._filter_position_overlaps(combo_candidates)

            if combo_candidates:
                # Create signature to avoid duplicates
                signature = tuple(sorted([c['text'] for c in combo_candidates]))
                if signature not in used_combinations:
                    used_combinations.add(signature)
                    combinations.append({
                        'candidates': combo_candidates,
                        'reason': f'Fallback {len(combo_candidates)}-way combination',
                        'size': len(combo_candidates),
                        'priority': 100 - combo_num  # Higher priority for earlier combinations
                    })

            if len(combinations) >= target_generate:
                break

        # Return top max_combinations
        return combinations[:max_combinations]

    def _generate_candidate_transformations(self, candidate: Dict) -> List[str]:
        """Generate multiple transformation options for a single candidate."""
        import random
        
        domain = candidate['domain']
        topic = candidate['topic']
        text = candidate['text']
        
        transformations = []
        
        if domain == 'math':
            if topic == 'fraction':
                if text == '3/4':
                    transformations = ['three quarters', 'three-fourths', 'three quarters of the total', '0.75']
                elif text == '1/2':
                    transformations = ['half', 'one half', 'fifty percent', '0.5']
                elif text == '1/4':
                    transformations = ['one quarter', 'twenty-five percent', 'a quarter', '0.25']
                else:
                    transformations = [text.replace('/', ' divided by '), f"the fraction {text}"]
            elif topic == 'number':
                if text.isdigit():
                    num = int(text)
                    word_form = self._number_to_words(num)
                    transformations = [word_form, f"the number {text}", f"a value of {text}"]
                else:
                    transformations = [f"the number {text}", f"a value of {text}"]
            elif topic == 'geometry':
                if text == 'rectangle':
                    transformations = ['four-sided figure', 'rectangular shape', 'quadrilateral', 'four-sided geometric figure']
                elif text == 'area':
                    transformations = ['two-dimensional space', 'surface area', 'space occupied', 'two-dimensional space occupied']
                else:
                    transformations = [f"geometric {text}", f"the {text}"]
            elif topic == 'unit':
                if 'cm' in text:
                    num = text.replace(' cm', '').replace('cm', '')
                    transformations = [f"{self._number_to_words(int(num))} centimeters", f"{num} centimeters", f"{text} in length"]
                else:
                    transformations = [text, f"the unit {text}"]
        
        elif domain == 'temporal':
            if topic == 'time':
                if '3:00 PM' in text:
                    transformations = ['fifteen hundred hours', 'three in the afternoon', 'three o\'clock in the afternoon', '15:00']
                elif 'AM' in text or 'PM' in text:
                    transformations = [text.replace('AM', ' in the morning').replace('PM', ' in the afternoon'), f"the time {text}"]
                else:
                    transformations = [f"the time {text}", text]
            elif topic == 'duration':
                if '2 hours' in text:
                    transformations = ['120 minutes', 'two hours', 'a duration of 2 hours', 'a duration of 120 minutes']
                elif 'hour' in text:
                    transformations = [f"a duration of {text}", f"the time span of {text}"]
                else:
                    transformations = [f"a duration of {text}", text]
            elif topic == 'day':
                if text == 'Monday':
                    transformations = ['the start of the week', 'the first day of the week', 'the beginning of the work week']
                else:
                    transformations = [f"the day {text}", text]
        
        elif domain == 'nl':
            if topic == 'person':
                if text == 'John':
                    transformations = ['a person named John', 'an individual named John', 'someone called John']
                else:
                    transformations = [f"a person named {text}", f"an individual named {text}"]
            elif topic == 'action':
                if text == 'walks':
                    transformations = ['travels on foot', 'moves by walking', 'proceeds on foot']
                elif text == 'Calculate':
                    transformations = ['Determine', 'Find', 'Compute', 'Work out']
                else:
                    transformations = [text, f"the action of {text}"]
            elif topic == 'object':
                if text == 'meeting':
                    transformations = ['scheduled appointment', 'business meeting', 'appointment']
                elif text == 'number':
                    transformations = ['numerical value', 'numeric quantity', 'value']
                else:
                    transformations = [f"the {text}", text]
            elif topic == 'quantity':
                if '5 miles' in text:
                    transformations = ['five miles', 'a distance of 5 miles', 'a distance of five miles']
                else:
                    transformations = [text, f"the quantity {text}"]
        
        # Fallback: at least return the original
        if not transformations:
            transformations = [text]
        
        return transformations
    
    def _number_to_words(self, num: int) -> str:
        """Convert number to words (basic implementation)."""
        words = {
            1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five',
            6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten',
            11: 'eleven', 12: 'twelve', 13: 'thirteen', 14: 'fourteen', 15: 'fifteen',
            16: 'sixteen', 17: 'seventeen', 18: 'eighteen', 19: 'nineteen', 20: 'twenty',
            24: 'twenty-four', 25: 'twenty-five', 30: 'thirty'
        }
        return words.get(num, str(num))
    
    def _create_combination_variation(self, problem: str, combo_data: Dict) -> Dict:
        """Create a meaningful variation for a candidate combination."""
        import random
        
        candidates = combo_data['candidates']
        
        # Generate multiple transformation options for each candidate and randomly select one
        selected_transformations = {}
        candidate_details = []
        
        for candidate in candidates:
            transformations = self._generate_candidate_transformations(candidate)
            # Randomly select one transformation for variety
            selected_transformation = random.choice(transformations)
            selected_transformations[candidate['text']] = selected_transformation
            candidate_details.append(f"'{candidate['text']}' ‚Üí '{selected_transformation}' ({candidate['domain']}:{candidate['topic']})")
        
        # Include domain-specific static patterns as guidance
        static_guidance = self._get_static_guidance_for_combination(candidates)
        
        system_prompt = f"""You are an expert at creating meaningful question variations by transforming multiple candidates simultaneously.

CRITICAL REQUIREMENTS:
1. PRESERVE exact numerical answer and question intent
2. USE EXACTLY the specified transformations provided
3. TRANSFORM all specified candidates using the given transformations
4. ENSURE mathematical/logical validity
5. Use PLAIN TEXT only - no formatting

{static_guidance}

ABSOLUTELY FORBIDDEN:
‚úó Identity transformations: "apple" ‚Üí "apple" (same-to-same is NOT a transformation)
‚úó Changing core question logic or numerical answer
‚úó Modifying transformations that were provided
‚úó Changing problem structure or intent

QUALITY EXAMPLES OF COMPLETE TRANSFORMATIONS:

Example 1 (Math word problem):
Original: "A car travels 60 miles in 2 hours. What is its speed?"
Transformations: "60" ‚Üí "sixty" | "miles" ‚Üí "mi" | "2 hours" ‚Üí "120 minutes"
‚úì GOOD: "A car travels sixty mi in 120 minutes. What is its speed?"
‚úó BAD: "A vehicle goes 60 miles in 2 hours. What's the velocity?" (changed core logic)

Example 2 (Temporal problem):
Original: "Meeting starts at 3:00 PM and lasts 90 minutes. When does it end?"
Transformations: "3:00 PM" ‚Üí "fifteen hundred hours" | "90 minutes" ‚Üí "one and a half hours"
‚úì GOOD: "Meeting starts at fifteen hundred hours and lasts one and a half hours. When does it end?"
‚úó BAD: "Session begins at 3:00 PM lasting 90 minutes. What's the conclusion time?" (changed wording beyond transformations)

Example 3 (Mixed domains):
Original: "John walks 3/4 of a mile in 15 minutes. How fast does he walk?"
Transformations: "John" ‚Üí "a person" | "walks" ‚Üí "travels on foot" | "3/4" ‚Üí "three quarters"
‚úì GOOD: "A person travels on foot three quarters of a mile in 15 minutes. How fast does he walk?"
‚úó BAD: "John walks 3/4 mile in 15 mins. What's his pace?" (didn't use exact transformations)

OUTPUT FORMAT: Return ONLY the modified question wrapped in <question> tags.
Example: <question>Your modified question here</question>"""

        user_prompt = f"""Original: {problem}

Apply these EXACT transformations:
{chr(10).join(candidate_details)}

Create ONE variation using EXACTLY the specified transformations while preserving exact answer and intent."""

        try:
            if hasattr(self.model_client, 'get_model_response'):
                responses = self.model_client.get_model_response([system_prompt], [user_prompt])
                response = responses[0] if responses else ""
            else:
                response = str(self.model_client.generate(user_prompt, system_prompt))
            
            # Extract question from tags
            question_match = re.search(r'<question>(.*?)</question>', response, re.DOTALL)
            if question_match:
                cleaned = clean_model_response(question_match.group(1).strip())
                
                if cleaned and is_valid_question(cleaned):
                    return {
                        'original_problem': problem,
                        'modified_problem': cleaned,
                        'transformation_type': f'unified_combination_{combo_data["size"]}way',
                        'candidates_transformed': [c['text'] for c in candidates],
                        'selected_transformations': selected_transformations,
                        'transformation_details': candidate_details,
                        'combination_size': combo_data['size'],
                        'confidence': 'model_generated',
                        'domains_involved': list(set(c['domain'] for c in candidates))
                    }
        except Exception as e:
            logger.debug(f"      ‚ö†Ô∏è Failed variation: {e}")
        
        return None
    
    def _get_static_guidance_for_combination(self, candidates: List[Dict]) -> str:
        """Generate domain-specific guidance based ONLY on domains actually used in this combination."""

        domains = set(c['domain'] for c in candidates)

        if not domains:
            return ""

        guidance = f"DOMAIN-SPECIFIC TRANSFORMATION GUIDANCE (for domains: {', '.join(sorted(domains))}):\n"

        if 'math' in domains:
            guidance += """
MATHEMATICAL TRANSFORMATIONS:

üö® CRITICAL MATHEMATICAL SEMANTIC RULES - MUST FOLLOW:
1. MUST PRESERVE NUMERICAL VALUE (answer cannot change!)
   ‚úì "3/4" ‚Üí "0.75" | "three quarters" | "75%"  (all equal 0.75)
   ‚úì "60 miles" ‚Üí "96.5 kilometers"  (equivalent distance)
   ‚úó "3/4" ‚Üí "4/3" | "0.34" | "80%"  (different values!)
   ‚úó "60 miles" ‚Üí "60 kilometers"  (not equivalent!)

2. NUMBER FORMAT ONLY (digit ‚Üî word, never change value)
   ‚úì "5" ‚Üí "five" | "fifteen" | "5.0"
   ‚úó "5" ‚Üí "six" | "4" | "5.5"  (changes value - breaks answer!)

3. UNIT CONVERSIONS MUST BE CORRECT
   ‚úì "60 miles" ‚Üí "96.5 km"  (1 mile = 1.609 km)
   ‚úì "2 hours" ‚Üí "120 minutes"  (1 hour = 60 minutes)
   ‚úó "60 miles" ‚Üí "60 km"  (wrong conversion!)
   ‚úó "2 hours" ‚Üí "200 minutes"  (wrong conversion!)

4. REPRESENTATION FORMAT (fraction ‚Üî decimal ‚Üî percentage)
   ‚úì "0.5" ‚Üí "1/2" | "50%" | "half"  (all equal)
   ‚úì "75%" ‚Üí "3/4" | "0.75" | "three quarters"
   ‚úó "0.5" ‚Üí "2/3" | "60%" | "one third"  (not equal!)

5. OPERATION SYMBOLS ONLY (never change operation type)
   ‚úì "+" ‚Üí "plus" | "add" | "sum"
   ‚úì "√ó" ‚Üí "times" | "multiply" | "product"
   ‚úó "+" ‚Üí "√ó" | "√∑" | "subtract"  (changes operation!)

üö´ ABSOLUTELY FORBIDDEN MATHEMATICAL TRANSFORMATIONS:
‚úó Changing values: "5" ‚Üí "6" | "3/4" ‚Üí "2/3" | "0.5" ‚Üí "0.6"
‚úó Wrong unit conversion: "miles" ‚Üí "kilometers" without adjusting number
‚úó Incorrect equivalence: "50%" ‚Üí "3/4" | "1/3" ‚Üí "0.5"
‚úó Changing operations: "+" ‚Üí "√ó" | "divide" ‚Üí "multiply"
‚úó Nonsensical math: "five quarters" | "half of three quarters of six"

ALLOWED MATHEMATICAL TRANSFORMATIONS:
‚Ä¢ Fractions: 3/4 ‚Üí three quarters | 1/2 ‚Üí half | 0.75 ‚Üí three-fourths | 2/3 ‚Üí two thirds | 5/8 ‚Üí five eighths | 7/10 ‚Üí seven tenths | 1/3 ‚Üí one third
‚Ä¢ Decimals: 0.25 ‚Üí one quarter | 3.14 ‚Üí three point one four | 12.5 ‚Üí twelve and a half | 0.333 ‚Üí one third | 2.5 ‚Üí two and a half | 0.1 ‚Üí one tenth | 6.75 ‚Üí six point seven five
‚Ä¢ Percentages: 50% ‚Üí half | 25% ‚Üí one quarter | 75% ‚Üí three quarters | 100% ‚Üí completely | 10% ‚Üí one tenth | 33% ‚Üí one third | 66% ‚Üí two thirds | 20% ‚Üí one fifth
‚Ä¢ Geometry: rectangle ‚Üí four-sided figure | area ‚Üí two-dimensional space | perimeter ‚Üí boundary distance | circle ‚Üí round shape | triangle ‚Üí three-sided polygon | square ‚Üí four equal sides | cube ‚Üí six-faced solid | sphere ‚Üí round 3D object | cone ‚Üí pointed circular solid
‚Ä¢ Units: cm ‚Üí centimeters | m¬≤ ‚Üí square meters | kg ‚Üí kilograms | mph ‚Üí miles per hour | ¬∞C ‚Üí degrees Celsius | ft ‚Üí feet | lb ‚Üí pounds | oz ‚Üí ounces | km/h ‚Üí kilometers per hour | ml ‚Üí milliliters | in ‚Üí inches
‚Ä¢ Operations: + ‚Üí plus | √ó ‚Üí times | √∑ ‚Üí divided by | - ‚Üí minus | = ‚Üí equals | ‚â§ ‚Üí less than or equal to | > ‚Üí greater than | ¬± ‚Üí plus or minus | ‚â† ‚Üí not equal to | ‚âà ‚Üí approximately equal to
‚Ä¢ Numbers: 24 ‚Üí twenty-four | 15 ‚Üí fifteen | 1st ‚Üí first | 2nd ‚Üí second | 100 ‚Üí one hundred | 1000 ‚Üí one thousand | 0.5 ‚Üí half | 1.5 ‚Üí one and a half | 2.0 ‚Üí two point zero
‚Ä¢ Mathematical terms: sum ‚Üí total | product ‚Üí result of multiplication | quotient ‚Üí division result | difference ‚Üí subtraction result | average ‚Üí mean value | median ‚Üí middle value | ratio ‚Üí proportion | factor ‚Üí divisor
‚Ä¢ Algebraic: x ‚Üí unknown variable | f(x) ‚Üí function of x | y = mx + b ‚Üí linear equation | solve for ‚Üí find the value of | equation ‚Üí mathematical statement | expression ‚Üí mathematical phrase | coefficient ‚Üí numerical multiplier
‚Ä¢ Statistics: mean ‚Üí average | variance ‚Üí spread measure | standard deviation ‚Üí dispersion metric | probability ‚Üí likelihood | sample ‚Üí subset of data | population ‚Üí complete dataset

STRUCTURAL MATHEMATICAL PATTERNS:
‚Ä¢ Algebraic equivalent: x+5 ‚Üí 5+x | a√ób ‚Üí b√óa | (x+y)+z ‚Üí x+(y+z) | 2(x+3) ‚Üí 2x+6 | x-y ‚Üí -(y-x) (commutativity/distributivity/equivalence)
‚Ä¢ Fraction-decimal conversion: 3/4 ‚Üí 0.75 | 1/8 ‚Üí 0.125 | 7/10 ‚Üí 0.7 | 0.6 ‚Üí 3/5 | 0.25 ‚Üí 1/4 | 1/3 ‚Üí 0.333 | 5/8 ‚Üí 0.625 (format robustness)
‚Ä¢ Fraction-percentage conversion: 3/4 ‚Üí 75% | 1/5 ‚Üí 20% | 0.8 ‚Üí 80% | 25% ‚Üí 1/4 | 1/2 ‚Üí 50% | 2/5 ‚Üí 40% (representation flexibility)
‚Ä¢ Unit conversion: 1 mile ‚Üí 1.6 km | 1 kg ‚Üí 2.2 lbs | 1 inch ‚Üí 2.54 cm | 100¬∞C ‚Üí 212¬∞F | 1 gallon ‚Üí 3.78 liters (measurement equivalence)
‚Ä¢ Geometry equivalent: rectangle ‚Üí rectangular shape | square ‚Üí four equal sides | circle ‚Üí circular shape | triangle ‚Üí three-sided figure | perimeter ‚Üí boundary length | volume ‚Üí 3D space | radius ‚Üí center-to-edge distance
‚Ä¢ Trigonometric equivalent: sin(x) ‚Üí sine(x) | cos(Œ∏) ‚Üí cosine of theta | tan(30¬∞) ‚Üí tangent of thirty degrees | œÄ ‚Üí pi | ‚àö ‚Üí square root of | sin¬≤(x) ‚Üí sine squared of x
‚Ä¢ Mathematical notation: f(x) ‚Üí function f of x | dy/dx ‚Üí derivative of y with respect to x | ‚à´ ‚Üí integral of | Œ£ ‚Üí sum of | lim ‚Üí limit of | n! ‚Üí factorial of n | |x| ‚Üí absolute value of x"""

        if 'temporal' in domains:
            guidance += """
TEMPORAL TRANSFORMATIONS:

üö® CRITICAL TEMPORAL SEMANTIC RULES - MUST FOLLOW:
1. TIME POINT ‚Üí TIME POINT ONLY (never to duration/frequency)
   ‚úì "2:00 PM" ‚Üí "14:00" | "two in the afternoon" | "fourteen hundred hours"
   ‚úó "2:00 PM" ‚Üí "two hours" | "fifteen hours at noon" | "120 minutes"

2. DURATION ‚Üí DURATION ONLY (never to time point/frequency)
   ‚úì "2 hours" ‚Üí "120 minutes" | "two hours" | "7200 seconds"
   ‚úó "2 hours" ‚Üí "2:00 PM" | "at two o'clock" | "twice"

3. FREQUENCY ‚Üí FREQUENCY ONLY (never to time point/duration)
   ‚úì "daily" ‚Üí "every day" | "once per day" | "each day"
   ‚úó "daily" ‚Üí "at noon" | "24 hours" | "one day"

4. DATE ‚Üí DATE ONLY (never to time point/duration)
   ‚úì "March 15" ‚Üí "the 15th of March" | "3/15" | "mid-March"
   ‚úó "March 15" ‚Üí "three hours" | "at 3:15" | "fifteen days"

5. MUST PRESERVE VALUE EQUIVALENCE:
   ‚úì "2:00 PM" ‚Üí "14:00" (same moment, different format)
   ‚úì "2 hours" ‚Üí "120 minutes" (same duration, different unit)
   ‚úó "2:00 PM" ‚Üí "3:00 PM" (different moment - answer would change!)
   ‚úó "2 hours" ‚Üí "3 hours" (different duration - answer would change!)

üö´ ABSOLUTELY FORBIDDEN TEMPORAL TRANSFORMATIONS:
‚úó Time point to duration: "2:00 PM" ‚Üí "two hours"
‚úó Duration to time point: "30 minutes" ‚Üí "2:30 PM"
‚úó Mixing incompatible concepts: "2:00 PM" ‚Üí "fifteen hours at noon"
‚úó Changing values: "2:00 PM" ‚Üí "3:00 PM" (breaks answer!)
‚úó Nonsensical combinations: "half past two hours" | "3 o'clock minutes"

ALLOWED TEMPORAL TRANSFORMATIONS:
‚Ä¢ Time formats: 3:00 PM ‚Üí fifteen hundred hours | 2:00 AM ‚Üí two in the morning | 14:30 ‚Üí half past two PM | 06:45 ‚Üí quarter to seven AM | 9:15 ‚Üí nine fifteen | 12:30 PM ‚Üí half past noon
‚Ä¢ Duration: 2 hours ‚Üí 120 minutes | 30 minutes ‚Üí half an hour | 1 day ‚Üí 24 hours | 1 week ‚Üí 7 days | 1 year ‚Üí 365 days | 90 seconds ‚Üí minute and a half | 45 minutes ‚Üí three quarters of an hour | 3.5 hours ‚Üí three and a half hours
‚Ä¢ Time periods: morning ‚Üí AM hours | evening ‚Üí PM hours | noon ‚Üí 12:00 PM | midnight ‚Üí 12:00 AM | dawn ‚Üí early morning | dusk ‚Üí evening time | afternoon ‚Üí post-noon hours | night ‚Üí after sunset
‚Ä¢ Days: Monday ‚Üí start of the week | Friday ‚Üí end of work week | weekend ‚Üí Saturday and Sunday | weekday ‚Üí Monday through Friday | Tuesday ‚Üí second day of week | Wednesday ‚Üí midweek | Thursday ‚Üí fourth weekday
‚Ä¢ Months: January ‚Üí first month | December ‚Üí last month | Q1 ‚Üí first quarter | spring ‚Üí March-May | summer ‚Üí June-August | fall ‚Üí September-November | winter ‚Üí December-February | April ‚Üí fourth month
‚Ä¢ Sequence: first ‚Üí initial | last ‚Üí final | next ‚Üí following | previous ‚Üí preceding | before ‚Üí earlier than | after ‚Üí later than | subsequent ‚Üí coming after | prior ‚Üí coming before | simultaneous ‚Üí at the same time
‚Ä¢ Frequency: daily ‚Üí every day | weekly ‚Üí once per week | monthly ‚Üí once per month | annually ‚Üí once per year | hourly ‚Üí every hour | biannual ‚Üí twice yearly | fortnightly ‚Üí every two weeks | quarterly ‚Üí four times per year
‚Ä¢ Ages: 25 years old ‚Üí quarter century | decades ‚Üí tens of years | century ‚Üí 100 years | millennium ‚Üí 1000 years | 18 years ‚Üí adult age | 5 years ‚Üí half a decade
‚Ä¢ Relative time: now ‚Üí at this moment | soon ‚Üí in a short time | recently ‚Üí not long ago | eventually ‚Üí at some future time | immediately ‚Üí right away | later ‚Üí at a future point | presently ‚Üí currently

STRUCTURAL TEMPORAL PATTERNS:
‚Ä¢ Time 12hr-24hr conversion: 3:00 PM ‚Üí 15:00 | 11:30 AM ‚Üí 11:30 | 8:45 PM ‚Üí 20:45 | 12:00 AM ‚Üí 00:00 | 1:15 AM ‚Üí 01:15 | 6:30 PM ‚Üí 18:30 (format conversion)
‚Ä¢ Time 24hr-12hr conversion: 15:00 ‚Üí 3:00 PM | 09:30 ‚Üí 9:30 AM | 23:15 ‚Üí 11:15 PM | 00:00 ‚Üí 12:00 AM | 13:45 ‚Üí 1:45 PM | 17:20 ‚Üí 5:20 PM (reverse conversion)
‚Ä¢ Duration unit conversion: 2 hours ‚Üí 120 minutes | 90 minutes ‚Üí 1.5 hours | 3 days ‚Üí 72 hours | 2 weeks ‚Üí 14 days | 1 month ‚Üí ~30 days | 180 seconds ‚Üí 3 minutes | 1.5 days ‚Üí 36 hours (unit changes)
‚Ä¢ Date format variants: 03/15/2024 ‚Üí March 15, 2024 | 15/03/2024 ‚Üí 15th March 2024 | 2024-03-15 ‚Üí Mar 15, 2024 | 3/15 ‚Üí March 15th | 15 March ‚Üí the 15th of March (date representations)
‚Ä¢ Ordinal sequence conversion: first ‚Üí 1st | second ‚Üí 2nd | third ‚Üí 3rd | twenty-first ‚Üí 21st | hundredth ‚Üí 100th | fourth ‚Üí 4th | tenth ‚Üí 10th (sequence formats)
‚Ä¢ Schedule frequency conversion: daily ‚Üí every day | bi-weekly ‚Üí every two weeks | quarterly ‚Üí every 3 months | semi-annually ‚Üí twice per year | tri-weekly ‚Üí three times per week | monthly ‚Üí once a month (frequency expressions)
‚Ä¢ Temporal preposition variants: at 3PM ‚Üí when clock shows 3PM | on Monday ‚Üí during Monday | in January ‚Üí throughout January | by Friday ‚Üí before Friday ends | until noon ‚Üí up to 12PM | since morning ‚Üí from AM onwards (preposition changes)
‚Ä¢ Relative time expressions: yesterday ‚Üí the day before | tomorrow ‚Üí the following day | last week ‚Üí the previous week | next month ‚Üí the upcoming month | two days ago ‚Üí day before yesterday | in three days ‚Üí three days from now (relative expressions)"""

        if 'nl' in domains:
            guidance += """
LINGUISTIC TRANSFORMATIONS:
‚Ä¢ People: John ‚Üí a person named John | student ‚Üí individual learner | teacher ‚Üí educator | worker ‚Üí employee | child ‚Üí young person | adult ‚Üí grown-up | customer ‚Üí buyer | manager ‚Üí supervisor | friend ‚Üí companion | neighbor ‚Üí nearby resident
‚Ä¢ Actions: walks ‚Üí travels on foot | runs ‚Üí moves quickly | drives ‚Üí operates a vehicle | writes ‚Üí puts words on paper | reads ‚Üí examines text | buys ‚Üí purchases | sells ‚Üí offers for sale | thinks ‚Üí contemplates | speaks ‚Üí communicates verbally
‚Ä¢ Verbs: Calculate ‚Üí Determine the value of | Find ‚Üí Locate | Solve ‚Üí Work out the solution | Complete ‚Üí Finish | Begin ‚Üí Start | End ‚Üí Conclude | Create ‚Üí Make | Destroy ‚Üí Break down | Build ‚Üí Construct | Measure ‚Üí Quantify
‚Ä¢ Objects: meeting ‚Üí scheduled appointment | book ‚Üí written publication | car ‚Üí motor vehicle | house ‚Üí residential building | phone ‚Üí communication device | computer ‚Üí computing device | table ‚Üí flat surface | chair ‚Üí seating furniture | door ‚Üí entrance barrier
‚Ä¢ Quantities: number ‚Üí numerical value | amount ‚Üí quantity | total ‚Üí sum | few ‚Üí small number | many ‚Üí large number | several ‚Üí some | dozen ‚Üí twelve items | pair ‚Üí two items | handful ‚Üí small amount | multitude ‚Üí very large number
‚Ä¢ Locations: home ‚Üí residence | office ‚Üí workplace | school ‚Üí educational institution | store ‚Üí retail establishment | park ‚Üí public green space | library ‚Üí book repository | hospital ‚Üí medical facility | restaurant ‚Üí dining establishment | airport ‚Üí air terminal
‚Ä¢ Descriptors: big ‚Üí large | small ‚Üí tiny | fast ‚Üí quick | slow ‚Üí leisurely | good ‚Üí excellent | bad ‚Üí poor | easy ‚Üí simple | hard ‚Üí difficult | beautiful ‚Üí attractive | ugly ‚Üí unattractive | strong ‚Üí powerful | weak ‚Üí feeble | bright ‚Üí luminous
‚Ä¢ Relationships: and ‚Üí plus | or ‚Üí alternatively | with ‚Üí alongside | without ‚Üí lacking | between ‚Üí in the middle of | among ‚Üí within a group of | through ‚Üí via | during ‚Üí throughout | despite ‚Üí in spite of | because ‚Üí due to
‚Ä¢ Abstract concepts: problem ‚Üí challenge | solution ‚Üí answer | method ‚Üí approach | process ‚Üí procedure | result ‚Üí outcome | goal ‚Üí objective | idea ‚Üí concept | reason ‚Üí cause | effect ‚Üí consequence | opinion ‚Üí viewpoint
‚Ä¢ Conjunctions: but ‚Üí however | so ‚Üí therefore | because ‚Üí since | if ‚Üí provided that | while ‚Üí whereas | although ‚Üí even though | unless ‚Üí except if | until ‚Üí up to the time that

STRUCTURAL LINGUISTIC PATTERNS:
‚Ä¢ Grammatical voice: "John solved the problem" ‚Üí "The problem was solved by John" | "Mary reads books" ‚Üí "Books are read by Mary" | "They built the house" ‚Üí "The house was built by them" (active/passive conversion)
‚Ä¢ Question-statement conversion: "What is X?" ‚Üí "The value of X is..." | "How much does it cost?" ‚Üí "The cost is..." | "Where is it?" ‚Üí "It is located at..." | "When does it start?" ‚Üí "It starts at..." (interrogative transformation)
‚Ä¢ Formal-informal register: "Please calculate" ‚Üí "Figure out" | "Determine the solution" ‚Üí "Find the answer" | "Subsequently" ‚Üí "Then" | "Therefore" ‚Üí "So" | "Commence" ‚Üí "Start" | "Terminate" ‚Üí "End" (register shifting)
‚Ä¢ Pronoun-noun substitution: "He walks" ‚Üí "The man walks" | "It costs $5" ‚Üí "The item costs $5" | "They arrived" ‚Üí "The visitors arrived" | "She bought" ‚Üí "The woman bought" (explicit reference)
‚Ä¢ Modal verb variations: "You must do X" ‚Üí "You need to do X" | "You can solve" ‚Üí "You are able to solve" | "You should try" ‚Üí "You ought to try" | "You may leave" ‚Üí "You are permitted to leave" (modality changes)
‚Ä¢ Prepositional variations: "on the table" ‚Üí "upon the table" | "in the box" ‚Üí "inside the box" | "near the store" ‚Üí "close to the store" | "under the bridge" ‚Üí "beneath the bridge" | "above the line" ‚Üí "over the line" (preposition alternatives)
‚Ä¢ Compound-simple conversion: "The red car" ‚Üí "The car that is red" | "Walking quickly" ‚Üí "Moving in a quick manner" | "Very tall" ‚Üí "Extremely tall" | "Highly intelligent" ‚Üí "Possessing great intelligence" (structural expansion)
‚Ä¢ Negation patterns: "is not" ‚Üí "isn't" | "does not have" ‚Üí "lacks" | "cannot" ‚Üí "is unable to" | "will not" ‚Üí "refuses to" | "did not go" ‚Üí "didn't go" | "has not arrived" ‚Üí "hasn't arrived" (negation variations)"""

        return guidance
    
    def _organize_by_debugging_capabilities(self, variations: List[Dict]) -> Dict[str, List[Dict]]:
        """Organize variations by debugging capabilities."""
        
        capabilities = {
            'numerical_robustness': [],
            'format_dependency': [],
            'linguistic_flexibility': [],
            'temporal_reasoning': [],
            'mathematical_equivalence': [],
            'integration_capability': []
        }
        
        for var in variations:
            capability = self._assign_debugging_capability(var)
            if capability in capabilities:
                var['debugging_capability'] = capability
                capabilities[capability].append(var)
        
        return {k: v for k, v in capabilities.items() if v}  # Only return non-empty
    
    def _organize_by_domains(self, variations: List[Dict]) -> Dict[str, List[Dict]]:
        """Organize variations by domains."""
        
        domains = {'math': [], 'temporal': [], 'nl': [], 'cross_domain': []}
        
        for var in variations:
            involved_domains = var.get('domains_involved', [])
            if len(involved_domains) > 1:
                domains['cross_domain'].append(var)
            elif involved_domains:
                domain = involved_domains[0]
                if domain in domains:
                    domains[domain].append(var)
        
        return {k: v for k, v in domains.items() if v}
    
    def _assign_debugging_capability(self, variation: Dict) -> str:
        """Assign variation to primary debugging capability."""
        
        domains = variation.get('domains_involved', [])
        size = variation.get('combination_size', 1)
        
        # Priority-based assignment
        if size >= 4 or len(domains) >= 3:
            return 'integration_capability'
        elif 'math' in domains:
            return 'mathematical_equivalence'
        elif 'temporal' in domains:
            return 'temporal_reasoning'
        elif 'nl' in domains:
            return 'linguistic_flexibility'
        else:
            return 'numerical_robustness'
    
    def _detect_and_merge_dependencies(self, problem: str, candidates: List[Dict]) -> List[Dict]:
        """Detect and merge dependent candidates like time expressions."""

        # PRIORITY 1: Critical format specifiers that must be preserved as single units
        critical_format_patterns = [
            r'\b[Hh]:?[Mm]:?[Ss]\b',                    # "H:M:S", "h:m:s"
            r'\b[Hh]{1,2}:?[Mm]{1,2}:?[Ss]{1,2}\b',    # "HH:MM:SS", "hh:mm:ss"
            r'\bhours?:minutes?:seconds?\b',             # "hours:minutes:seconds"
            r'\bhour:minute:second\b',                   # "hour:minute:second"
            r'\b[A-Z]+:[A-Z]+:[A-Z]+\b',                # "A:B:C" format specifiers
            r'\b[A-Z]+:[A-Z]+\b',                       # "A:B" format specifiers
        ]

        # PRIORITY 2: Complex time expressions
        compound_time_patterns = [
            r'(\d+\.?\d*)\s+(hours?)\s+(\d+\.?\d*)\s+(minutes?)\s+(\d+\.?\d*)\s+(seconds?)',  # "2 hours 30 minutes 45 seconds"
            r'(\d+\.?\d*)\s+(hours?)\s+(\d+\.?\d*)\s+(minutes?)',                            # "2 hours 30 minutes"
            r'(\d+\.?\d*)\s+(minutes?)\s+(\d+\.?\d*)\s+(seconds?)',                          # "30 minutes 45 seconds"
        ]

        # PRIORITY 3: Numeric time formats
        numeric_time_patterns = [
            r'\b(\d+):(\d+):(\d+)\b',                   # "12:30:45" (HH:MM:SS)
            r'\b(\d+):(\d+)\b',                         # "12:30" (HH:MM) - with word boundaries
        ]

        # PRIORITY 4: Mathematical and rate expressions
        math_patterns = [
            r'(\d+\.?\d*)\s*([+\-*/])\s*(\d+\.?\d*)',              # "2 + 3", "4.5 * 2"
            r'(\d+\.?\d*)\s+(times)\s+(\d+\.?\d*)',                # "2 times 3"
            r'(\d+\.?\d*)\s+(plus)\s+(\d+\.?\d*)',                 # "2 plus 3"
            r'(\d+\.?\d*)\s+([a-zA-Z]+)\s+(per)\s+([a-zA-Z]+)',   # "5 miles per hour"
            r'(\d+\.?\d*)/([a-zA-Z]+)',                            # "60/minute"
        ]

        merged_candidates = []
        used_indices = set()

        # Track all patterns found to avoid conflicts
        found_spans = []

        # STEP 1: Process critical format specifiers first - these have highest priority
        logger.debug(f"    üîç Checking for critical format specifiers...")
        for pattern in critical_format_patterns:
            matches = re.finditer(pattern, problem, re.IGNORECASE)
            for match in matches:
                matched_text = match.group(0)
                start, end = match.span()

                # Check if this span conflicts with already found patterns
                if any(start < existing_end and end > existing_start for existing_start, existing_end in found_spans):
                    continue

                # Find candidates within this format specifier
                overlapping_candidates = []
                for i, candidate in enumerate(candidates):
                    if i in used_indices:
                        continue

                    # Check if candidate overlaps with this format specifier
                    cand_start = problem.find(candidate['text'])
                    if cand_start != -1:
                        cand_end = cand_start + len(candidate['text'])
                        if (cand_start >= start and cand_end <= end) or \
                           (cand_start < end and cand_end > start):  # Any overlap
                            overlapping_candidates.append(candidate)
                            used_indices.add(i)

                # Always preserve format specifiers as single units, even with only 1 candidate
                if overlapping_candidates:
                    merged_candidate = {
                        'text': matched_text,
                        'domain': 'temporal',
                        'topic': 'format_specifier',
                        'start': start,
                        'end': end,
                        'merged_from': [c['text'] for c in overlapping_candidates],
                        'dependency_type': 'critical_format_specifier'
                    }
                    merged_candidates.append(merged_candidate)
                    found_spans.append((start, end))
                    logger.debug(f"    ‚ö†Ô∏è Protected format specifier: {matched_text} (merged from {[c['text'] for c in overlapping_candidates]})")

        # STEP 2: Process compound time expressions
        logger.debug(f"    üîç Checking for compound time expressions...")
        for pattern in compound_time_patterns:
            matches = re.finditer(pattern, problem, re.IGNORECASE)
            for match in matches:
                matched_text = match.group(0)
                start, end = match.span()

                # Check for conflicts with existing patterns
                if any(start < existing_end and end > existing_start for existing_start, existing_end in found_spans):
                    continue

                time_candidates = []
                for i, candidate in enumerate(candidates):
                    if i in used_indices:
                        continue
                    if candidate['text'] in matched_text:
                        time_candidates.append(candidate)
                        used_indices.add(i)

                if len(time_candidates) >= 2:
                    merged_candidate = {
                        'text': matched_text,
                        'domain': 'temporal',
                        'topic': 'compound_time_expression',
                        'start': start,
                        'end': end,
                        'merged_from': [c['text'] for c in time_candidates],
                        'dependency_type': 'coherent_time_expression'
                    }
                    merged_candidates.append(merged_candidate)
                    found_spans.append((start, end))
                    logger.debug(f"    Merged compound time: {matched_text} from {[c['text'] for c in time_candidates]}")

        # STEP 3: Process numeric time formats
        logger.debug(f"    üîç Checking for numeric time formats...")
        for pattern in numeric_time_patterns:
            matches = re.finditer(pattern, problem)
            for match in matches:
                matched_text = match.group(0)
                start, end = match.span()

                # Check for conflicts
                if any(start < existing_end and end > existing_start for existing_start, existing_end in found_spans):
                    continue

                time_candidates = []
                for i, candidate in enumerate(candidates):
                    if i in used_indices:
                        continue
                    if candidate['text'] in matched_text:
                        time_candidates.append(candidate)
                        used_indices.add(i)

                if len(time_candidates) >= 2:
                    merged_candidate = {
                        'text': matched_text,
                        'domain': 'temporal',
                        'topic': 'numeric_time_format',
                        'start': start,
                        'end': end,
                        'merged_from': [c['text'] for c in time_candidates],
                        'dependency_type': 'coherent_time_format'
                    }
                    merged_candidates.append(merged_candidate)
                    found_spans.append((start, end))
                    logger.debug(f"    Merged numeric time: {matched_text} from {[c['text'] for c in time_candidates]}")

        # STEP 4: Process mathematical expressions
        logger.debug(f"    üîç Checking for mathematical expressions...")
        for pattern in math_patterns:
            matches = re.finditer(pattern, problem, re.IGNORECASE)
            for match in matches:
                matched_text = match.group(0)
                start, end = match.span()

                # Check for conflicts
                if any(start < existing_end and end > existing_start for existing_start, existing_end in found_spans):
                    continue

                math_candidates = []
                for i, candidate in enumerate(candidates):
                    if i in used_indices:
                        continue
                    if candidate['text'] in matched_text:
                        math_candidates.append(candidate)
                        used_indices.add(i)

                if len(math_candidates) >= 2:
                    merged_candidate = {
                        'text': matched_text,
                        'domain': 'mathematical',
                        'topic': 'composite_expression',
                        'start': start,
                        'end': end,
                        'merged_from': [c['text'] for c in math_candidates],
                        'dependency_type': 'coherent_mathematical_expression'
                    }
                    merged_candidates.append(merged_candidate)
                    found_spans.append((start, end))
                    logger.debug(f"    Merged math expression: {matched_text} from {[c['text'] for c in math_candidates]}")

        # STEP 5: Add remaining non-dependent candidates
        for i, candidate in enumerate(candidates):
            if i not in used_indices:
                merged_candidates.append(candidate)

        logger.debug(f"    üìä Dependency detection results: {len(candidates)} ‚Üí {len(merged_candidates)} candidates")
        return merged_candidates
    
    @staticmethod
    def get_all_transformation_types():
        """
        Get all transformation types including generic and persona variations.
        This is used by both the engine and the cross-problem batching pipeline.

        Returns:
            Dict of transformation types with their prompts, capabilities, and examples
        """
        transformation_types = {
            'counterfactual': {
                'prompt': """Create a counterfactual version by changing the scenario context while keeping the exact same numerical values and mathematical relationships to preserve the identical answer. Transform objects, people, or situations but maintain all numbers, measurements, and calculations exactly as they are. The mathematical operation and final answer must remain unchanged.

Examples:
- "15 + 25" ‚Üí "If you had 15 apples and received 25 more apples, how many would you have?"
- "Rectangle 8cm √ó 5cm area" ‚Üí "A garden plot 8 meters √ó 5 meters, what's the area?"
- "Train 60 mph for 2.5 hours" ‚Üí "If a car drives 60 mph for 2.5 hours, how far?"

Your output should be ONLY the transformed problem, nothing else.""",
                'capability': 'context_preservation',
                'examples': ["Different object with same dimensions", "Different situation with same numbers", "Alternative context with identical measurements"]
            },
            'interrogative_expansion': {
                'prompt': """Expand into a detailed multi-part question format while maintaining the same core calculation. Break down the problem into sequential questions that guide through the solution process. Include questions about methodology, intermediate steps, and final calculation. The expanded version should test understanding of the underlying process while keeping the same mathematical content.

Examples:
- "15 + 25" ‚Üí "If you have 15 items and receive 25 more items, how many items do you have in total? What operation should you use? Show the calculation step by step."
- "8cm √ó 5cm area" ‚Üí "Consider a rectangle with length 8cm and width 5cm. First, what formula calculates area? Second, what is 8 √ó 5? Finally, what is the area in square cm?"

Your output should be ONLY the expanded question format, nothing else.""",
                'capability': 'format_dependency',
                'examples': ["What is X? How do we calculate Y?", "Given A, what is B? Show the steps."]
            },
            'logical_formulation': {
                'prompt': """Reformulate using formal logical and mathematical language while preserving the exact same problem and calculation. Use mathematical terminology, variable notation, and formal problem statement structure. Transform natural language into mathematical language while keeping all numerical relationships identical.

Examples:
- "15 + 25" ‚Üí "Given two integers x = 15 and y = 25, determine the value of x + y."
- "Rectangle 8cm √ó 5cm" ‚Üí "Given a rectangle with length l = 8cm and width w = 5cm, calculate the area A where A = l √ó w."
- "60 mph for 2.5 hours" ‚Üí "Given velocity v = 60 mph and time t = 2.5 hours, find distance d using d = v √ó t."

Your output should be ONLY the logically formulated problem, nothing else.""",
                'capability': 'mathematical_equivalence',
                'examples': ["Given that..., determine...", "Let X represent..., find..."]
            },
            'rephrasing': {
                'prompt': """Rephrase using entirely different vocabulary and sentence structure while keeping the exact same meaning, numbers, and expected answer. Use synonyms, alternative expressions, and different grammatical constructions. The mathematical content must remain identical but expressed through completely different words and phrasing.

Examples:
- "What is 15 + 25?" ‚Üí "Determine the sum when fifteen is combined with twenty-five."
- "Rectangle area 8cm √ó 5cm" ‚Üí "Calculate the space occupied by a rectangular shape measuring 8 centimeters by 5 centimeters."
- "Train 60 mph, 2.5 hours, distance?" ‚Üí "A locomotive traveling at sixty miles per hour for two and a half hours covers what distance?"

Your output should be ONLY the rephrased problem, nothing else.""",
                'capability': 'linguistic_flexibility',
                'examples': ["Alternative wording", "Different expression style"]
            },
            'domain_shift': {
                'prompt': """Shift the context/domain while preserving the exact mathematical relationship and answer. Transform the setting, field, or application area while keeping all numerical values, operations, and relationships identical. Move from one domain (e.g., geometry, physics, finance) to another while maintaining the same calculation structure.

Examples:
- "Rectangle 8cm √ó 5cm area" ‚Üí "A computer screen 8 inches √ó 5 inches, what's the display area?"
- "15 apples + 25 apples" ‚Üí "15 dollars + 25 dollars in your wallet, total amount?"
- "60 mph for 2.5 hours" ‚Üí "Data transmission at 60 MB/hour for 2.5 hours, total data transferred?"

Your output should be ONLY the domain-shifted problem, nothing else.""",
                'capability': 'context_preservation',
                'examples': ["Business context ‚Üí Scientific context", "Daily life ‚Üí Academic setting"]
            },
            'narrative_style': {
                'prompt': """Convert to a story-like narrative format with characters, setting, and plot while maintaining all numerical relationships and the same calculation. Create an engaging story that naturally incorporates the mathematical problem. Use storytelling elements like characters, dialogue, setting, and sequence of events, but ensure the core mathematical question and answer remain unchanged.

Examples:
- "15 + 25" ‚Üí "Once upon a time, Sarah found 15 gold coins in an old chest. Later that day, she discovered another 25 coins hidden under a rock. How many gold coins did Sarah have in total?"
- "Rectangle 8cm √ó 5cm" ‚Üí "In a magical kingdom, the royal garden had a rectangular flower bed that measured 8 centimeters long and 5 centimeters wide. The garden fairy needed to know the total area to plant her special flowers."
- "60 mph, 2.5 hours" ‚Üí "Detective Jones was chasing a suspect who was driving at exactly 60 miles per hour. After pursuing for 2.5 hours, how far had they traveled from the starting point?"

Your output should be ONLY the narrative version, nothing else.""",
                'capability': 'format_dependency',
                'examples': ["Once upon a time...", "In a story format..."]
            },
            'unit_conversion': {
                'prompt': """Convert ALL measurements to different but mathematically equivalent units so the final numerical answer remains exactly the same when expressed in consistent output units. Transform inches to centimeters, hours to minutes, dollars to cents, etc., while preserving the mathematical relationship.

CRITICAL: VERIFY ALL CONVERSIONS ARE MATHEMATICALLY CORRECT before applying them!

CORRECT Examples (verify the math):
- "15 cm + 25 cm" ‚Üí "150 millimeters + 250 millimeters" (15√ó10=150, 25√ó10=250, both sum to 40cm) ‚úì
- "Rectangle 8 cm √ó 5 cm" ‚Üí "Rectangle 80 mm √ó 50 mm" (8√ó10=80, 5√ó10=50, both area = 40cm¬≤) ‚úì
- "60 mph for 2 hours" ‚Üí "96.56 km/h for 120 minutes" (60√ó1.609=96.56, 2√ó60=120, both = 120 miles) ‚úì
- "30 minutes to walk" ‚Üí "1800 seconds to walk" (30√ó60=1800) ‚úì
- "2:00 PM" ‚Üí "840 minutes past midnight" (2PM = 14:00, 14√ó60=840) ‚úì
- "45 minutes" ‚Üí "three quarters of an hour" (45 = 60√ó0.75) ‚úì

WRONG Examples (mathematically incorrect - DO NOT use these):
‚úó "30 minutes" ‚Üí "three quarters of an hour" (30 ‚â† 45, this is WRONG!)
‚úó "2:00 PM" ‚Üí "1200 minutes past midnight" (840 ‚â† 1200, this is WRONG! 1200 min = 20:00 = 8PM)
‚úó "45 minutes" ‚Üí "half an hour" (45 ‚â† 30, this is WRONG!)
‚úó "1.5 hours" ‚Üí "60 minutes" (90 ‚â† 60, this is WRONG!)
‚úó "9:00 AM" ‚Üí "600 minutes past midnight" (540 ‚â† 600, this is WRONG! 9√ó60=540)

MANDATORY: Calculate and verify each conversion factor before applying. Ensure proportional equivalence is maintained.

Your output should be ONLY the unit-converted problem, nothing else.""",
                'capability': 'unit_sensitivity',
                'examples': ["15 cm √ó 20 cm ‚Üí 150 mm √ó 200 mm (both = 300 cm¬≤)", "2 hours ‚Üí 120 minutes", "$5.00 ‚Üí 500 cents"]
            },
            'format_variation': {
                'prompt': """Change the presentation format while keeping identical mathematical content. Transform the layout, structure, or visual presentation without altering the numbers, relationships, or expected answer. Convert between different formats like bullet points, paragraphs, tables, or fill-in-the-blank style while maintaining the same mathematical problem.

Examples:
- "What is 15 + 25?" ‚Üí "Calculate: 15 + 25 = ____"
- "Rectangle with length 8cm and width 5cm, find area" ‚Üí "Length: 8cm ‚Ä¢ Width: 5cm ‚Ä¢ Area: ?"
- Paragraph format ‚Üí "Given the following: Length = 8cm, Width = 5cm. Question: What is the area?"

Your output should be ONLY the format-changed problem, nothing else.""",
                'capability': 'format_dependency',
                'examples': ["Bullet points ‚Üí paragraph", "Question ‚Üí statement with blank"]
            },
            'symbolic_representation': {
                'prompt': """Express using mathematical notation, symbols, and formal mathematical language while preserving the exact calculation. Use algebraic notation, mathematical symbols, variables, and formal mathematical expressions. Transform word problems into mathematical symbolic form while keeping the same numerical relationships and expected answer.

Examples:
- "15 plus 25" ‚Üí "Let x = 15, y = 25. Find: x + y"
- "Rectangle 8cm by 5cm area" ‚Üí "Given: l = 8cm, w = 5cm. Calculate: A = l √ó w"
- "60 mph for 2.5 hours distance" ‚Üí "Given: v = 60 mph, t = 2.5 hr. Find: d = v √ó t"

Your output should be ONLY the symbolic representation, nothing else.""",
                'capability': 'symbolic_processing',
                'examples': ["Let x = 15, y = 25. Find x + y", "Given: A = 8cm, B = 5cm. Calculate: A √ó B"]
            },
            'irrelevant_context': {
                'prompt': """Add irrelevant background information, distracting details, or unrelated context that doesn't affect the calculation but tests the ability to focus on relevant information. Include extra details, side stories, or additional information that should be ignored when solving the mathematical problem. The core calculation and answer must remain unchanged.

Examples:
- "15 + 25" ‚Üí "Yesterday it was raining heavily, and the weather forecast says tomorrow will be sunny. Today, if you have 15 apples and someone gives you 25 more apples, how many apples do you have in total? By the way, apples are your favorite fruit."
- "Rectangle 8cm √ó 5cm" ‚Üí "While thinking about what to have for lunch, calculate the area of a rectangle that measures 8 centimeters in length and 5 centimeters in width. The rectangle is blue, which is a nice color."

Your output should be ONLY the problem with irrelevant context, nothing else.""",
                'capability': 'distractor_resistance',
                'examples': ["Yesterday it rained, but today if you have 15 apples...", "While thinking about lunch, calculate: 8 √ó 5"]
            },
            'step_by_step_decomposition': {
                'prompt': """Break down into explicit, numbered step-by-step instructions that GUIDE the solution process WITHOUT solving it. Create a detailed procedural breakdown that describes WHAT TO DO at each step, not the actual results. This is a DECOMPOSITION of the approach, NOT a chain-of-thought solution.

CRITICAL REQUIREMENT: DO NOT include the final answer or any intermediate calculated results in the steps. Only describe the PROCESS to follow.

Examples:
- "15 + 25" ‚Üí "Step 1: Identify the first number from the problem. Step 2: Identify the second number from the problem. Step 3: Add these two numbers together. Step 4: State your final sum."
- "Rectangle area 8cm √ó 5cm" ‚Üí "Step 1: Identify the length dimension from the problem. Step 2: Identify the width dimension from the problem. Step 3: Recall the formula for calculating area of a rectangle. Step 4: Apply the formula by multiplying the two dimensions. Step 5: Express your result in the appropriate square units."
- "If it takes 30 minutes to walk to the store, and I leave at 2:00 PM, what time will I arrive?" ‚Üí "Step 1: Identify the starting time from the problem. Step 2: Identify the duration of the journey. Step 3: Add the duration to the starting time. Step 4: State your calculated arrival time."

WHAT TO AVOID:
‚úó BAD: "Step 4: State the final sum, which is 40" (includes answer!)
‚úì GOOD: "Step 4: State your final sum" (guides process only)
‚úó BAD: "Step 3: Add the duration to get 2:30 PM" (includes answer!)
‚úì GOOD: "Step 3: Add the duration to the starting time" (guides process only)

Your output should be ONLY the step-by-step decomposition, nothing else.""",
                'capability': 'procedure_following',
                'examples': ["Step 1: Identify..., Step 2: Calculate...", "First, ..., Then, ..., Finally, ..."]
            },
            'assumption_testing': {
                'prompt': """Make implicit assumptions explicit while keeping the same problem structure and calculation. State assumptions that are normally taken for granted, specify default units, clarify implicit conditions, or make hidden premises visible. This tests whether the model can handle explicitly stated assumptions versus implicit ones while maintaining the same mathematical content.

Examples:
- "15 + 25" ‚Üí "Assuming we're working with whole numbers in base-10 notation, what is 15 + 25?"
- "Rectangle 8cm √ó 5cm area" ‚Üí "Given a rectangle with length 8cm and width 5cm, assuming we're calculating area in square centimeters using the standard formula, what is the area?"
- "60 mph for 2.5 hours" ‚Üí "Assuming constant speed with no acceleration or stops, if traveling at 60 mph for exactly 2.5 hours, what distance is covered?"

Your output should be ONLY the assumption-explicit problem, nothing else.""",
                'capability': 'assumption_handling',
                'examples': ["Assuming standard units...", "Given that we're using..."]
            },
            'precision_variation': {
                'prompt': """Vary the precision and decimal representation of inputs while maintaining the expected level of precision in the output and the same final answer. Use different decimal places, scientific notation, or fractional representations while keeping the mathematical relationships identical. Test sensitivity to numerical precision representation.

Examples:
- "15 + 25" ‚Üí "15.0 + 25.0" or "15.00 + 25.00"
- "Rectangle 8cm √ó 5cm" ‚Üí "Rectangle 8.0 cm √ó 5.0 cm" or "Rectangle 8.000 cm √ó 5.000 cm"
- "60 mph for 2 hours" ‚Üí "60.0 mph for 2.00 hours" or "6.0 √ó 10¬π mph for 2.0 √ó 10‚Å∞ hours"

Your output should be ONLY the precision-varied problem, nothing else.""",
                'capability': 'precision_sensitivity',
                'examples': ["15.0 + 25.0", "8.00 cm √ó 5.00 cm", "2.50 hours at 60.0 mph"]
            },
            'negation_complexity': {
                'prompt': """Introduce negations, double negatives, or negative contexts while preserving the same underlying calculation and answer. Test the model's ability to parse negative constructions and maintain correct mathematical relationships despite linguistic complexity.

Examples:
- "15 + 25" ‚Üí "If you don't have 15 fewer than 55 items, and you don't lose 25 items you don't have, how many do you not lack?"
- "Rectangle 8cm √ó 5cm area" ‚Üí "A shape that is not anything other than a rectangle, with dimensions that are not different from 8cm by 5cm, has what area?"
- "60 mph for 2.5 hours" ‚Üí "If a vehicle doesn't travel at any speed other than 60 mph for no less than 2.5 hours, what distance is not left uncovered?"

Your output should be ONLY the negation-complex problem, nothing else.""",
                'capability': 'negation_parsing',
                'examples': ["Double negatives", "Implied negations", "Negative contexts"]
            },
            'cognitive_load_stress': {
                'prompt': """Increase cognitive load by adding multiple pieces of information to track, intermediate steps, or working memory demands while keeping the core calculation identical. Test whether additional cognitive burden causes model failure or maintains accuracy.

Examples:
- "15 + 25" ‚Üí "Maria has 15 red apples, 8 green apples, and 3 yellow apples. She gives away the 8 green apples and 3 yellow apples to friends. Then she receives 25 red apples from her neighbor. How many red apples does Maria have now?" (Answer still 15 + 25 = 40 red apples)
- "Rectangle 8cm √ó 5cm" ‚Üí "A garden has three sections: a square section (4cm √ó 4cm), a triangular section (base 6cm, height 2cm), and a rectangular section (8cm √ó 5cm). What is the area of just the rectangular section?"
- "60 mph for 2.5 hours" ‚Üí "A car travels for 30 minutes at 40 mph, then stops for 15 minutes, then travels for 2.5 hours at 60 mph, then travels for 45 minutes at 50 mph. What distance was covered during the 60 mph portion?"

Your output should be ONLY the cognitively loaded problem, nothing else.""",
                'capability': 'working_memory_capacity',
                'examples': ["Multiple tracking elements", "Intermediate steps", "Memory demands"]
            },
            'order_dependency': {
                'prompt': """Rearrange the order of information presentation while keeping all the same data and requiring the same calculation. Test whether models are sensitive to information order or can extract relevant details regardless of presentation sequence.

Examples:
- "15 + 25" ‚Üí "The total you need to find involves these two numbers: 25 and 15. Add them together."
- "Rectangle 8cm √ó 5cm area" ‚Üí "To find the area: the width is 5cm, use the area formula, the length is 8cm."
- "60 mph, 2.5 hours, distance?" ‚Üí "For 2.5 hours of travel time, at a speed of 60 miles per hour, calculate the distance."

Your output should be ONLY the reordered problem, nothing else.""",
                'capability': 'information_order_robustness',
                'examples': ["Key info last", "Mixed order presentation", "Non-sequential facts"]
            },
            'ambiguous_phrasing': {
                'prompt': """Create grammatically ambiguous phrasing that could be interpreted multiple ways, but where only one interpretation yields the correct mathematical answer. Test the model's ability to select the mathematically sensible interpretation over potentially confusing linguistic structures.

Examples:
- "15 + 25" ‚Üí "When you combine fifteen with twenty-five more than nothing, what do you get?" (Ambiguous: 15 + (25 + 0) or (15 + 25) + 0)
- "Rectangle 8cm √ó 5cm" ‚Üí "Find the area of a rectangle with length eight and width five centimeters squared." (Ambiguous: 5 cm¬≤ as width vs 5cm width)
- "60 mph for 2.5 hours" ‚Üí "Traveling sixty miles every hour for two and a half hours covers what distance?" (Ambiguous phrasing but clear intent)

Your output should be ONLY the ambiguously phrased problem, nothing else.""",
                'capability': 'ambiguity_resolution',
                'examples': ["Multiple valid parsings", "Grammatical ambiguity", "Contextual disambiguation"]
            },
            'anchoring_bias_test': {
                'prompt': """Include large irrelevant numbers or prominent distractors that might bias the reasoning process, while the actual calculation remains simple and unchanged. Test whether models are influenced by irrelevant numerical anchors or maintain focus on relevant quantities.

Examples:
- "15 + 25" ‚Üí "In a warehouse containing 50,000 items total, you have 15 special widgets and receive 25 more special widgets. How many special widgets do you have?" (50,000 is irrelevant)
- "Rectangle 8cm √ó 5cm" ‚Üí "On a 1000-acre farm, there's a small rectangular garden plot measuring 8cm √ó 5cm. What's the area of the garden plot?" (1000 acres irrelevant)
- "60 mph, 2.5 hours" ‚Üí "A highway has a 500-mile total length, but you only travel 60 mph for 2.5 hours. How far did you travel?" (500 miles irrelevant)

Your output should be ONLY the anchoring-test problem, nothing else.""",
                'capability': 'numerical_anchoring_resistance',
                'examples': ["Large irrelevant numbers", "Prominent distractors", "Anchoring quantities"]
            },
            'scale_extremes': {
                'prompt': """Use extremely large or extremely small numbers while maintaining the same proportional relationships and calculation structure. Test model performance with edge cases, scientific notation, or numbers outside typical ranges.

Examples:
- "15 + 25" ‚Üí "1.5 √ó 10¬π‚Å∞ + 2.5 √ó 10¬π‚Å∞" or "0.0000015 + 0.0000025"
- "Rectangle 8cm √ó 5cm" ‚Üí "Rectangle 8,000,000 km √ó 5,000,000 km area" or "Rectangle 0.008mm √ó 0.005mm area"
- "60 mph for 2.5 hours" ‚Üí "60,000,000 mph for 2.5 hours distance" or "0.00006 mph for 2.5 hours distance"

Your output should be ONLY the scale-extreme problem, nothing else.""",
                'capability': 'numerical_scale_robustness',
                'examples': ["Very large numbers", "Very small numbers", "Scientific notation"]
            },
            'implicit_constraint_test': {
                'prompt': """Add implicit constraints or unstated conditions that must be inferred to solve correctly, while keeping the same mathematical answer. Test the model's ability to recognize and work with unstated assumptions or implicit requirements.

Examples:
- "15 + 25" ‚Üí "You have some apples. After finding 15 more and then 25 more, you have 40 total. How many did you start with?" (Implicit: started with 0)
- "Rectangle 8cm √ó 5cm" ‚Üí "A fence around a rectangular garden uses 26cm of fencing. If one side is 8cm, what's the garden's area?" (Implicit: other side must be 5cm)
- "60 mph for 2.5 hours" ‚Üí "A journey covers 150 miles. If traveling at 60 mph, how long did it take?" (Implicit: 2.5 hours, but asks backwards)

Your output should be ONLY the implicit-constraint problem, nothing else.""",
                'capability': 'implicit_reasoning',
                'examples': ["Unstated assumptions", "Hidden constraints", "Reverse inference"]
            },
            'temporal_confusion': {
                'prompt': """Introduce temporal sequence complexity, past/future tense mixing, or time-based confusion while maintaining the same mathematical relationships. Test the model's ability to track temporal logic and maintain calculation accuracy despite time-based linguistic complexity.

Examples:
- "15 + 25" ‚Üí "Yesterday you will have 15 items. Tomorrow you had received 25 more items. How many items do you currently not have yet?"
- "Rectangle 8cm √ó 5cm" ‚Üí "Before the rectangle was measured as 8cm √ó 5cm, after it was built, what area will it have had?"
- "60 mph for 2.5 hours" ‚Üí "If you had traveled 60 mph for what will be 2.5 hours yesterday, how far would you have gone tomorrow?"

Your output should be ONLY the temporally confused problem, nothing else.""",
                'capability': 'temporal_logic_resistance',
                'examples': ["Tense mixing", "Temporal confusion", "Time logic complexity"]
            },
            'false_premise_detection': {
                'prompt': """Include false or contradictory premises that don't affect the core calculation but test whether the model gets distracted by logical inconsistencies or maintains mathematical focus. The math should still work despite the contradictions.

Examples:
- "15 + 25" ‚Üí "In a world where 2 + 2 = 5, you have 15 apples and receive 25 more apples. Using normal arithmetic, how many apples do you have?"
- "Rectangle 8cm √ó 5cm" ‚Üí "This square rectangle measures 8cm by 5cm. Despite having 5 sides, what is its area using the standard formula?"
- "60 mph for 2.5 hours" ‚Üí "A stationary car moving at 60 mph travels for 2.5 hours while parked. Ignoring the contradiction, what distance would be calculated?"

Your output should be ONLY the false-premise problem, nothing else.""",
                'capability': 'contradiction_resilience',
                'examples': ["Logical contradictions", "False premises", "Inconsistent contexts"]
            },
            'emotional_bias_injection': {
                'prompt': """Add emotional language, bias-inducing context, or emotionally charged scenarios while keeping the mathematical content identical. Test whether emotional framing affects numerical reasoning accuracy.

Examples:
- "15 + 25" ‚Üí "You desperately need exactly 40 items to save your family, but you only have 15 precious items and can barely afford 25 more expensive items. How many do you have?"
- "Rectangle 8cm √ó 5cm" ‚Üí "Calculate the cramped area of this tiny, inadequate rectangle measuring only 8cm √ó 5cm that represents your disappointing living space."
- "60 mph for 2.5 hours" ‚Üí "Recklessly speeding at a dangerous 60 mph for an exhausting 2.5 hours, how far did this irresponsible driver travel?"

Your output should be ONLY the emotionally biased problem, nothing else.""",
                'capability': 'emotional_neutrality',
                'examples': ["Emotional language", "Bias induction", "Charged contexts"]
            },
            'meta_reference_loop': {
                'prompt': """Create self-referential or meta-level references that mention the problem-solving process itself while maintaining the same calculation. Test the model's ability to handle recursive references or meta-cognitive loops without confusion.

Examples:
- "15 + 25" ‚Üí "This math problem asks you to solve this math problem: what is 15 + 25? The answer to this problem that asks for 15 + 25 is what number?"
- "Rectangle 8cm √ó 5cm" ‚Üí "When calculating the area of this rectangle (8cm √ó 5cm), you are calculating an area calculation. What is the result of this area calculation?"
- "60 mph for 2.5 hours" ‚Üí "The question 'how far is traveled at 60 mph for 2.5 hours' has an answer. What is the answer to that question?"

Your output should be ONLY the meta-referential problem, nothing else.""",
                'capability': 'meta_reference_handling',
                'examples': ["Self-reference", "Meta-loops", "Recursive mentions"]
            },
            'scientist_persona': {
                'prompt': """Frame the problem from a scientist's perspective using scientific methodology, hypothesis-testing language, experimental design thinking, and technical precision. Maintain the same mathematical content but express it through scientific reasoning and terminology.

Examples:
- "15 + 25" ‚Üí "In this experimental setup, we observe 15 specimens in the control group. Upon introducing 25 additional specimens to the population, what is the total sample size for statistical analysis?"
- "Rectangle 8cm √ó 5cm" ‚Üí "Given a rectangular test surface with dimensions 8.0 cm √ó 5.0 cm, calculate the cross-sectional area for our surface tension experiments."
- "60 mph for 2.5 hours" ‚Üí "A particle accelerates to a constant velocity of 60 mph and maintains this speed for a duration of 2.5 hours. Calculate the total displacement."

Your output should be ONLY the scientist-framed problem, nothing else.""",
                'capability': 'persona_sensitivity_scientific',
                'examples': ["Experimental language", "Technical precision", "Scientific methodology"]
            },
            'artist_persona': {
                'prompt': """Frame the problem from an artist's perspective using creative language, aesthetic terminology, visual imagery, and artistic concepts. Maintain the same mathematical content but express it through artistic and creative frameworks.

Examples:
- "15 + 25" ‚Üí "In your art studio, you have 15 brushes of cerulean blue paint strokes on your canvas. You add 25 more vibrant brushstrokes to create depth and texture. How many brushstrokes of blue bring life to your masterpiece?"
- "Rectangle 8cm √ó 5cm" ‚Üí "You're designing a miniature canvas frame with proportions 8cm in length and 5cm in width. What is the total surface area available for your intimate artistic expression?"
- "60 mph for 2.5 hours" ‚Üí "Imagine colors flowing across your canvas at 60 brushstrokes per hour for 2.5 continuous hours of creative flow. How many total brushstrokes capture your artistic vision?"

Your output should be ONLY the artist-framed problem, nothing else.""",
                'capability': 'persona_sensitivity_artistic',
                'examples': ["Creative language", "Aesthetic terminology", "Visual imagery"]
            },
            'chef_persona': {
                'prompt': """Frame the problem from a professional chef's perspective using culinary language, cooking terminology, kitchen measurements, and food preparation concepts. Maintain the same mathematical content but express it through culinary expertise.

Examples:
- "15 + 25" ‚Üí "In your kitchen prep, you've already diced 15 onions for the dinner service. The sous chef brings you 25 more perfectly diced onions. How many onions total are ready for tonight's mise en place?"
- "Rectangle 8cm √ó 5cm" ‚Üí "You need to cut rectangular pasta sheets measuring 8cm by 5cm for your signature dish. What is the surface area of each pasta sheet for proper sauce coverage?"
- "60 mph for 2.5 hours" ‚Üí "Your bread dough needs to rise at a temperature that increases at 60 degrees per hour for 2.5 hours. How many total degrees of temperature change will your dough experience?"

Your output should be ONLY the chef-framed problem, nothing else.""",
                'capability': 'persona_sensitivity_culinary',
                'examples': ["Culinary language", "Kitchen terminology", "Food preparation"]
            },
            'detective_persona': {
                'prompt': """Frame the problem from a detective's perspective using investigative language, case-solving methodology, evidence analysis, and criminal investigation terminology. Maintain the same mathematical content but express it through detective work and forensic thinking.

Examples:
- "15 + 25" ‚Üí "At the crime scene, we found 15 fingerprints on the first surface. The forensics team discovered 25 additional matching prints on the second surface. How many total pieces of fingerprint evidence do we have for this case?"
- "Rectangle 8cm √ó 5cm" ‚Üí "The suspect's footprint shows a rectangular pattern measuring 8cm in length and 5cm in width. Calculate the total surface area of this crucial piece of evidence."
- "60 mph for 2.5 hours" ‚Üí "The getaway car was traveling at a constant speed of 60 mph for exactly 2.5 hours based on traffic camera timestamps. How far from the crime scene should we establish our search perimeter?"

Your output should be ONLY the detective-framed problem, nothing else.""",
                'capability': 'persona_sensitivity_investigative',
                'examples': ["Investigation language", "Evidence analysis", "Forensic terminology"]
            },
            'teacher_persona': {
                'prompt': """Frame the problem from an educator's perspective using pedagogical language, learning objectives, educational methodology, and classroom instruction terminology. Maintain the same mathematical content but express it through teaching and educational frameworks.

Examples:
- "15 + 25" ‚Üí "Class, for today's addition lesson, let's practice with this word problem: Sarah has 15 pencils in her desk organizer. Her teacher gives her 25 more pencils for the class project. How many pencils does Sarah have altogether?"
- "Rectangle 8cm √ó 5cm" ‚Üí "Students, in our geometry unit, we need to find the area of this rectangular piece of paper that measures 8 centimeters long and 5 centimeters wide. Remember to apply the area formula we learned."
- "60 mph for 2.5 hours" ‚Üí "For our physics lesson on distance calculations, consider this scenario: A school bus travels at 60 miles per hour for 2.5 hours on a field trip. What total distance will the students travel?"

Your output should be ONLY the teacher-framed problem, nothing else.""",
                'capability': 'persona_sensitivity_educational',
                'examples': ["Educational language", "Learning objectives", "Classroom instruction"]
            },
            'engineer_persona': {
                'prompt': """Frame the problem from an engineer's perspective using technical specifications, engineering terminology, system design language, and precise measurement standards. Maintain the same mathematical content but express it through engineering and technical frameworks.

Examples:
- "15 + 25" ‚Üí "In our system architecture, Module A requires 15 processing units and Module B requires 25 processing units. Calculate the total computational capacity needed for optimal system performance."
- "Rectangle 8cm √ó 5cm" ‚Üí "The circuit board component has rectangular dimensions of 8.0cm √ó 5.0cm. Determine the surface area available for component placement and thermal management."
- "60 mph for 2.5 hours" ‚Üí "The mechanical system operates at a constant velocity of 60 mph for 2.5 hours during the stress test. Calculate the total distance traveled to verify system endurance specifications."

Your output should be ONLY the engineer-framed problem, nothing else.""",
                'capability': 'persona_sensitivity_technical',
                'examples': ["Technical specifications", "Engineering terminology", "System design"]
            },
            'doctor_persona': {
                'prompt': """Frame the problem from a medical doctor's perspective using clinical language, medical terminology, patient care concepts, and healthcare measurement standards. Maintain the same mathematical content but express it through medical and healthcare frameworks.

Examples:
- "15 + 25" ‚Üí "In the clinical trial, we initially enrolled 15 patients in the treatment group. During the second phase, we added 25 more patients to ensure adequate statistical power. What is the total patient count for our study?"
- "Rectangle 8cm √ó 5cm" ‚Üí "The surgical incision site measures 8cm in length and 5cm in width. Calculate the total surface area that requires sterile coverage during the procedure."
- "60 mph for 2.5 hours" ‚Üí "The patient's heart rate stabilized at 60 beats per minute for 2.5 hours post-surgery. Calculate the total number of heartbeats during this monitoring period."

Your output should be ONLY the doctor-framed problem, nothing else.""",
                'capability': 'persona_sensitivity_medical',
                'examples': ["Clinical language", "Medical terminology", "Patient care concepts"]
            },
            'farmer_persona': {
                'prompt': """Frame the problem from a farmer's perspective using agricultural language, farming terminology, crop management concepts, and rural measurement practices. Maintain the same mathematical content but express it through agricultural and farming frameworks.

Examples:
- "15 + 25" ‚Üí "In the spring planting, I sowed 15 rows of corn in the north field. After preparing the soil, I planted 25 additional rows in the south field. How many total rows of corn will I be harvesting this season?"
- "Rectangle 8cm √ó 5cm" ‚Üí "The new seedbed plot measures 8 meters long and 5 meters wide. I need to calculate the total area to determine how much fertilizer to order for proper soil treatment."
- "60 mph for 2.5 hours" ‚Üí "The combine harvester moves through the wheat field at 60 acres per hour for 2.5 hours of steady work. How many total acres of wheat did we harvest today?"

Your output should be ONLY the farmer-framed problem, nothing else.""",
                'capability': 'persona_sensitivity_agricultural',
                'examples': ["Agricultural language", "Farming terminology", "Crop management"]
            },
            'athlete_persona': {
                'prompt': """Frame the problem from a professional athlete's perspective using sports terminology, performance measurement language, training concepts, and competitive athletics frameworks. Maintain the same mathematical content but express it through athletic and sports contexts.

Examples:
- "15 + 25" ‚Üí "During training camp, I completed 15 sprint intervals in the morning session. Coach added 25 more intervals for the afternoon workout. How many total sprints will I complete today to improve my performance?"
- "Rectangle 8cm √ó 5cm" ‚Üí "The playing field section I'm analyzing for my agility drills measures 8 meters in length and 5 meters in width. What's the total area I need to cover for maximum training efficiency?"
- "60 mph for 2.5 hours" ‚Üí "On my cycling training ride, I maintained a steady pace of 60 miles per hour for 2.5 hours to build endurance. What total distance did I cover in today's training session?"

Your output should be ONLY the athlete-framed problem, nothing else.""",
                'capability': 'persona_sensitivity_athletic',
                'examples': ["Sports terminology", "Performance measurement", "Training concepts"]
            },
            'musician_persona': {
                'prompt': """Frame the problem from a professional musician's perspective using musical terminology, rhythm and tempo concepts, composition language, and performance measurement frameworks. Maintain the same mathematical content but express it through musical and artistic performance contexts.

Examples:
- "15 + 25" ‚Üí "In our symphony orchestra, the string section has 15 violinists, and we're adding 25 more musicians from the conservatory for the upcoming concert. How many total string players will perform in our grand finale?"
- "Rectangle 8cm √ó 5cm" ‚Üí "The acoustic panel for our recording studio measures 8cm by 5cm. I need to calculate the surface area to determine the sound absorption coefficient for optimal recording quality."
- "60 mph for 2.5 hours" ‚Üí "The metronome is set to 60 beats per minute for our practice session lasting 2.5 hours. How many total beats will guide our ensemble rehearsal today?"

Your output should be ONLY the musician-framed problem, nothing else.""",
                'capability': 'persona_sensitivity_musical',
                'examples': ["Musical terminology", "Rhythm concepts", "Performance measurement"]
            },
            'missing_context': {
                'prompt': """Analyze if the problem is missing any essential context or information needed for complete understanding. If missing context exists, add it while preserving the original intent and answer. If NO context is missing (problem is already complete), return SKIP.

CRITICAL: Only add context if something is genuinely missing or unclear. Do NOT add context to well-formed, complete problems.

Examples of WHEN to add context:
- "Calculate the area" ‚Üí "Calculate the area of a rectangle with length 8cm and width 5cm" (dimensions were missing)
- "How long will it take?" ‚Üí "If traveling at 60 mph for 150 miles, how long will it take?" (speed and distance were missing)
- "What is the total?" ‚Üí "If you have 15 apples and receive 25 more, what is the total number of apples?" (quantities were missing)

Examples of WHEN to return SKIP (no missing context):
- "What is 15 + 25?" ‚Üí SKIP (complete problem)
- "Calculate the area of a rectangle 8cm √ó 5cm" ‚Üí SKIP (all info present)
- "If it takes 30 minutes to walk to the store, and I leave at 2:00 PM, what time will I arrive?" ‚Üí SKIP (complete problem)

Your output should be EITHER the problem with added context OR the word "SKIP" if no context is missing.""",
                'capability': 'context_completion',
                'examples': ["Add missing dimensions", "Add missing conditions", "SKIP if complete"]
            },
            'grammar_correction': {
                'prompt': """Identify and correct any spelling mistakes, grammatical errors, or typos in the problem while preserving the exact mathematical content and answer. Do NOT correct proper names, acronyms, or intentional stylistic choices.

IMPORTANT: Only correct actual errors. Do NOT change:
- Proper names (Sarah, John, IBM, NASA, etc.)
- Acronyms or abbreviations
- Technical terms
- Numbers or mathematical symbols

Examples of corrections:
- "Wat is 15 + 25?" ‚Üí "What is 15 + 25?" (spelling error: Wat ‚Üí What)
- "Calcuate the area of rectange 8cm √ó 5cm" ‚Üí "Calculate the area of rectangle 8cm √ó 5cm" (typos: Calcuate ‚Üí Calculate, rectange ‚Üí rectangle)
- "If it take 30 minutes too walk, and I leaves at 2:00 PM, what time will I arrived?" ‚Üí "If it takes 30 minutes to walk, and I leave at 2:00 PM, what time will I arrive?" (grammar errors)
- "Sarah has 5 apples. He gives 2 to Mary." ‚Üí "Sarah has 5 apples. She gives 2 to Mary." (pronoun agreement)

Examples of NO correction needed (return SKIP):
- "What is 15 + 25?" ‚Üí SKIP (no errors)
- "NASA launched 15 satellites and ESA launched 25 satellites" ‚Üí SKIP (acronyms are correct)
- "Calculate the area of a rectangle 8cm √ó 5cm" ‚Üí SKIP (no errors)

Your output should be EITHER the corrected problem OR the word "SKIP" if no corrections are needed.""",
                'capability': 'grammar_sensitivity',
                'examples': ["Fix spelling errors", "Fix grammar mistakes", "SKIP if correct"]
            },
            'programming_formulation': {
                'prompt': """Convert the mathematical problem into a programming task that captures the same intent and answer. Formulate as a code-writing problem, function implementation, or algorithmic challenge. The programming task should require solving the original mathematical problem as part of the implementation.

Guidelines:
- Use Python as the programming language
- Frame as function implementation or algorithmic problem
- Include input/output specifications
- Maintain the same numerical answer/relationship
- Test cases should validate the same mathematical content

Examples:
- "What is 15 + 25?" ‚Üí "Write a Python function that takes two integers as input and returns their sum. Test with inputs (15, 25). What is the expected output?"

- "Calculate the area of a rectangle with length 8cm and width 5cm" ‚Üí "Implement a function calculate_rectangle_area(length, width) that returns the area. Test with calculate_rectangle_area(8, 5). What is the expected result?"

- "If it takes 30 minutes to walk to the store, and I leave at 2:00 PM, what time will I arrive?" ‚Üí "Write a function add_duration(start_time, duration_minutes) that takes a time string ('2:00 PM') and duration in minutes (30) and returns the arrival time. Test with add_duration('2:00 PM', 30). What should it return?"

- "Sarah has 5 apples. She gives 2 to Mary. How many apples does Sarah have left?" ‚Üí "Implement a function calculate_remaining(initial, given_away) that returns items left. Test with calculate_remaining(5, 2). What is the output?"

Your output should be ONLY the programming formulation, nothing else.""",
                'capability': 'code_formulation',
                'examples': ["Function implementation", "Algorithmic challenge", "Code specification"]
            }
        }

        return transformation_types

    def _generate_generic_transformations(self, problem: str) -> List[Dict]:
        """Generate generic transformations using BATCHED model guidance."""

        if not self.model_client:
            logger.debug("    ‚ö†Ô∏è No model client available for generic transformations")
            return []

        logger.debug("üîÑ Generating generic transformations...")

        # Get all transformation types (generic + persona)
        transformation_types = self.get_all_transformation_types()

        # Count persona vs generic types
        persona_count = sum(1 for t in transformation_types.keys() if t.endswith('_persona'))
        generic_count = len(transformation_types) - persona_count
        logger.debug(f"  üöÄ BATCHING transformation generation: {generic_count} generic + {persona_count} persona types ({len(transformation_types)} total)...")
        
        # Prepare all prompts for batching
        system_prompts = []
        user_prompts = []
        type_lookup = []  # Track which transformation type each prompt corresponds to
        
        for trans_type, config in transformation_types.items():
            system_prompt = f"""You are an expert at creating question variations that test specific cognitive capabilities.

TASK: Create a {trans_type} variation of the given problem.

TRANSFORMATION GOAL: {config['prompt']}

CRITICAL REQUIREMENTS:
1. PRESERVE the exact numerical answer - the final result must be IDENTICAL
2. MAINTAIN all mathematical relationships and calculation methods
3. Use PLAIN TEXT only - no markdown formatting
4. Ensure the variation tests {config['capability']} capability
5. Make meaningful changes while keeping the same numerical answer
6. If changing units, convert ALL measurements proportionally

QUALITY STANDARDS:
‚úì GOOD: Changes presentation/context while preserving identical numerical answer
‚úó BAD: Any change that affects the final numerical result

ANSWER PRESERVATION EXAMPLES:
‚úì Rectangle 15cm √ó 20cm ‚Üí Rectangle 150mm √ó 200mm (both answer = 300 cm¬≤)
‚úì "Calculate area" ‚Üí "Find the surface space" (same calculation)
‚úó Rectangle 15cm √ó 20cm ‚Üí Rectangle 15mm √ó 20mm (different answers!)

OUTPUT FORMAT: Return ONLY the transformed question wrapped in <question> tags.
Example: <question>Your transformed question here</question>"""

            user_prompt = f"""Original Problem: {problem}

Create a {trans_type} variation that {config['prompt']}

Examples of this transformation type:
{chr(10).join(f"‚Ä¢ {ex}" for ex in config['examples'])}

Generate ONE high-quality {trans_type} variation."""

            system_prompts.append(system_prompt)
            user_prompts.append(user_prompt)
            type_lookup.append((trans_type, config))
        
        # BATCH CALL: Process all transformation types at once
        try:
            logger.debug(f"    üì¶ Batching {len(transformation_types)} generic transformation prompts...")
            if hasattr(self.model_client, 'get_model_response'):
                responses = self.model_client.get_model_response(system_prompts, user_prompts)
            else:
                # Fallback for non-batching clients
                responses = []
                for i, (sys_prompt, user_prompt) in enumerate(zip(system_prompts, user_prompts)):
                    response = str(self.model_client.generate(user_prompt, sys_prompt))
                    responses.append(response)
            
            # Process all responses
            generic_variations = []
            for i, (response, (trans_type, config)) in enumerate(zip(responses, type_lookup)):
                logger.debug(f"    Processing {trans_type} variation...")
                
                # Extract question from tags
                question_match = re.search(r'<question>(.*?)</question>', response, re.DOTALL)
                if question_match:
                    cleaned = clean_model_response(question_match.group(1).strip())
                    
                    if cleaned and is_valid_question(cleaned) and cleaned != problem:
                        # Determine prefix based on transformation type
                        if trans_type.endswith('_persona'):
                            prefix = 'persona'
                            domains = ['persona_based']
                            method = 'model_guided_persona'
                        else:
                            prefix = 'generic'
                            domains = ['generic']
                            method = 'model_guided_generic'

                        variation = {
                            'original_problem': problem,
                            'modified_problem': cleaned,
                            'transformation_type': f'{prefix}_{trans_type}',
                            'generation_method': method,
                            'detection_method': 'pattern_based',
                            'debugging_capability': config['capability'],
                            'confidence': 'model_generated',
                            'domains_involved': domains,
                            'original_component': trans_type,
                            'new_component': f'{trans_type}_variation'
                        }
                        generic_variations.append(variation)
                        logger.debug(f"      ‚úì Generated {trans_type} variation")
                    else:
                        logger.debug(f"      ‚ö†Ô∏è Invalid {trans_type} variation generated")
                else:
                    logger.debug(f"      ‚ö†Ô∏è No valid {trans_type} response")
                    
        except Exception as e:
            logger.debug(f"    ‚ùå Batch processing failed: {e}")
            # Fallback to individual processing
            return self._generate_generic_transformations_individual(problem, transformation_types)
        
        logger.debug(f"  ‚úÖ Batch completed: {len(generic_variations)} generic variations generated")

        # VALIDATE AND CORRECT all generic/persona variations
        if generic_variations:
            logger.debug(f"  üîç Applying validation to {len(generic_variations)} generic/persona variations...")
            generic_variations = self._batch_validate_and_correct_variations(problem, generic_variations)
            logger.debug(f"  ‚úÖ Validation completed for generic/persona variations")

        return generic_variations
    
    def _generate_generic_transformations_individual(self, problem: str, transformation_types: Dict) -> List[Dict]:
        """Fallback: Generate generic transformations individually if batching fails."""
        logger.debug(f"  ‚Ü© Falling back to individual generic transformation processing...")
        
        generic_variations = []
        for trans_type, config in transformation_types.items():
            logger.debug(f"    Individual processing for {trans_type}...")
            # Simplified fallback - just return empty list or basic transformations
            continue
        
        return generic_variations

    # ==================================================================================
    # RESTORED SOPHISTICATED COMPOSITE EXPRESSION DETECTION METHODS
    # ==================================================================================

    def find_composite_time_expression(self, problem: str, match_text: str, match_pos: int) -> str:
        """Find the complete composite time expression that contains this component"""
        # First try pattern-based detection (most reliable for temporal expressions)
        composite_patterns = [
            r'\d+\s+hours?,\s*\d+\s+minutes?,\s*(and\s+)?\d+\s+seconds?',  # "2 hours, 30 minutes, and 45 seconds"
            r'\d+\s+minutes?,\s*(and\s+)?\d+\s+seconds?',  # "30 minutes and 45 seconds"
            r'\d+\s+hours?,\s*(and\s+)?\d+\s+minutes?',   # "2 hours and 30 minutes"
            # Additional patterns that were missing
            r'\d+\.?\d*\s+hours?,\s*\d+\.?\d*\s+minutes?',  # "2.5 hours, 30.5 minutes"
            r'\d+\s+(hour|hr)\s+(period)',                  # "2 hour period"
            r'\d+\s+(minute|min)\s+(period)',               # "30 minute period"
        ]

        for pattern in composite_patterns:
            matches = list(re.finditer(pattern, problem, re.IGNORECASE))
            for composite_match in matches:
                # Check if our individual match is within this composite
                if (composite_match.start() <= match_pos < composite_match.end()):
                    return composite_match.group().strip()

        return None

    def find_composite_temporal_expression_via_dependencies(self, problem: str, match_text: str, match_pos: int) -> str:
        """Use spaCy dependency parsing to find composite temporal expressions containing this component"""
        if not hasattr(self, 'temporal_engine') or not self.temporal_engine.spacy_available:
            return None

        try:
            doc = self.temporal_engine.nlp(problem)

            # Find the token(s) corresponding to our match
            target_tokens = []
            for token in doc:
                if match_pos <= token.idx < match_pos + len(match_text):
                    target_tokens.append(token)

            if not target_tokens:
                return None

            # Look for coordinated temporal expressions
            for target_token in target_tokens:
                # Check for coordination (and, or) with temporal elements
                for child in target_token.children:
                    if child.dep_ == "conj" and any(time_word in child.text.lower() for time_word in
                                                  ['hour', 'minute', 'second', 'day', 'week', 'month', 'year']):
                        # Found coordination with temporal elements
                        start_idx = min(target_token.idx, child.idx)
                        end_idx = max(target_token.idx + len(target_token.text),
                                    child.idx + len(child.text))
                        return problem[start_idx:end_idx].strip()

                # Check if this token is part of a coordinated structure
                if target_token.head.dep_ == "conj":
                    head = target_token.head
                    if any(time_word in head.text.lower() for time_word in
                          ['hour', 'minute', 'second', 'day', 'week', 'month', 'year']):
                        start_idx = min(target_token.idx, head.idx)
                        end_idx = max(target_token.idx + len(target_token.text),
                                    head.idx + len(head.text))
                        return problem[start_idx:end_idx].strip()

        except Exception as e:
            logger.debug(f"    ‚ö†Ô∏è spaCy dependency parsing failed: {e}")

        return None

    def find_composite_expression_via_sympy(self, problem: str, match_text: str, match_pos: int) -> str:
        """
        Use SymPy to find mathematical composite expressions containing this component.
        This is the PRIMARY method for mathematical composite detection.
        """
        if not hasattr(self, 'math_engine') or not self.math_engine.sympy_available:
            return None

        try:
            # Extract all mathematical expressions from the problem
            math_expressions = self.math_engine.extract_mathematical_expressions_with_sympy(problem)

            # Check if our match is part of any extracted mathematical expression
            for expr_text, start_pos, end_pos in math_expressions:
                if start_pos <= match_pos < end_pos:
                    # Our match is within this mathematical expression
                    return expr_text.strip()

        except Exception as e:
            logger.debug(f"    ‚ö†Ô∏è SymPy composite detection failed: {e}")

        return None

    def find_composite_expression_via_dependencies(self, problem: str, match_text: str, match_pos: int) -> str:
        """
        HYBRID approach: Use SymPy FIRST for mathematical expressions, then fall back to spaCy dependencies.
        This maintains backward compatibility while improving mathematical composite detection.
        """

        # PHASE 1: Try SymPy-based mathematical composite detection (PRIMARY for math)
        if hasattr(self, 'math_engine') and self.math_engine.sympy_available:
            sympy_composite = self.find_composite_expression_via_sympy(problem, match_text, match_pos)
            if sympy_composite:
                logger.debug(f"    üßÆ Found mathematical composite via SymPy: '{sympy_composite}' - will handle with model")
                return sympy_composite

        # PHASE 2: Fall back to spaCy dependency parsing (for non-mathematical composites or SymPy failures)
        if not hasattr(self, 'math_engine') or not self.math_engine.spacy_available:
            return None

        try:
            doc = self.math_engine.nlp(problem)

            # Find the token(s) corresponding to our match
            target_tokens = []
            for token in doc:
                if match_pos <= token.idx < match_pos + len(match_text):
                    target_tokens.append(token)

            if not target_tokens:
                return None

            # Look for mathematical coordination and compound expressions
            for target_token in target_tokens:
                # Check for coordination with mathematical elements
                for child in target_token.children:
                    if child.dep_ == "conj" and (child.pos_ == "NUM" or
                                               any(math_word in child.text.lower() for math_word in
                                                  ['plus', 'minus', 'times', 'divided', 'per', 'rate'])):
                        # Found coordination with mathematical elements
                        start_idx = min(target_token.idx, child.idx)
                        end_idx = max(target_token.idx + len(target_token.text),
                                    child.idx + len(child.text))
                        return problem[start_idx:end_idx].strip()

                # Check for compound numerical expressions
                if target_token.pos_ == "NUM":
                    # Look for nearby mathematical operators or units
                    for neighbor in doc[max(0, target_token.i-2):min(len(doc), target_token.i+3)]:
                        if neighbor.text in ['+', '-', '*', '/', 'times', 'plus', 'minus', 'per']:
                            # Expand to include the full mathematical expression
                            start_idx = min(target_token.idx, neighbor.idx)
                            end_idx = max(target_token.idx + len(target_token.text),
                                        neighbor.idx + len(neighbor.text))
                            return problem[start_idx:end_idx].strip()

        except Exception as e:
            logger.debug(f"    ‚ö†Ô∏è spaCy dependency parsing failed: {e}")

        return None

    def find_composite_nl_expression_via_dependencies(self, problem: str, match_text: str, match_pos: int) -> str:
        """Use spaCy dependency parsing to find composite NL expressions containing this component"""
        if not hasattr(self, 'nl_engine') or not self.nl_engine.spacy_available:
            return None

        try:
            doc = self.nl_engine.nlp(problem)

            # Find the token(s) corresponding to our match
            target_tokens = []
            for token in doc:
                if match_pos <= token.idx < match_pos + len(match_text):
                    target_tokens.append(token)

            if not target_tokens:
                return None

            # Look for coordinated entities and compound expressions
            for target_token in target_tokens:
                # Check for coordination with similar entities
                for child in target_token.children:
                    if child.dep_ == "conj" and child.pos_ in ["NOUN", "PROPN"]:
                        # Found coordination with nominal elements
                        start_idx = min(target_token.idx, child.idx)
                        end_idx = max(target_token.idx + len(target_token.text),
                                    child.idx + len(child.text))
                        return problem[start_idx:end_idx].strip()

                # Check for compound nouns and adjective-noun combinations
                if target_token.pos_ in ["NOUN", "PROPN"]:
                    compound_start = target_token.idx
                    compound_end = target_token.idx + len(target_token.text)

                    # Look for preceding adjectives or compound elements
                    for neighbor in doc[max(0, target_token.i-2):target_token.i]:
                        if neighbor.head == target_token and neighbor.dep_ in ["amod", "compound"]:
                            compound_start = neighbor.idx

                    # Look for following compound elements
                    for neighbor in doc[target_token.i+1:min(len(doc), target_token.i+3)]:
                        if neighbor.head == target_token and neighbor.dep_ == "compound":
                            compound_end = neighbor.idx + len(neighbor.text)

                    if compound_start != target_token.idx or compound_end != target_token.idx + len(target_token.text):
                        return problem[compound_start:compound_end].strip()

        except Exception as e:
            logger.debug(f"    ‚ö†Ô∏è spaCy NL dependency parsing failed: {e}")

        return None

    # ==================================================================================
    # COLLECTION METHODS AND SKIPPING LOGIC
    # ==================================================================================

    def should_skip_individual_transformation(self, problem: str, match_text: str, match_pos: int) -> bool:
        """Check if this component is part of a composite time expression and should be skipped"""
        composite = self.find_composite_time_expression(problem, match_text, match_pos)
        if composite:
            logger.debug(f"    üìã Found composite: '{composite}' - will handle with model")
            return True
        return False

    def should_skip_individual_transformation_via_deps(self, problem: str, match_text: str, match_pos: int) -> bool:
        """Check if this component is part of a composite expression using dependency parsing"""
        composite = self.find_composite_expression_via_dependencies(problem, match_text, match_pos)
        if composite:
            logger.debug(f"    üîó Found composite via dependencies: '{composite}' - will handle with model")
            return True
        return False

    def should_skip_individual_nl_transformation_via_deps(self, problem: str, match_text: str, match_pos: int) -> bool:
        """Check if this component is part of a composite NL expression using dependency parsing"""
        composite = self.find_composite_nl_expression_via_dependencies(problem, match_text, match_pos)
        if composite:
            logger.debug(f"    üîó Found NL composite via dependencies: '{composite}' - will handle with model")
            return True
        return False

    def collect_composite_time_expressions(self, problem: str, detected_topics: Dict[str, List[Tuple[str, int]]]) -> Set[str]:
        """Collect all composite time expressions found in the problem"""
        composites = set()

        if 'durations' in detected_topics:
            for match_text, match_pos in detected_topics['durations']:
                composite = self.find_composite_time_expression(problem, match_text, match_pos)
                if composite:
                    composites.add(composite)

        return composites

    def collect_composite_expressions_via_deps(self, problem: str, detected_topics: Dict[str, List[Tuple[str, int]]]) -> Set[str]:
        """Collect composite expressions using dependency parsing"""
        composites = set()

        for topic, matches in detected_topics.items():
            for match_text, match_pos in matches:
                composite = self.find_composite_expression_via_dependencies(problem, match_text, match_pos)
                if composite:
                    composites.add(composite)

        return composites

    def collect_composite_nl_expressions_via_deps(self, problem: str, nl_entities: Dict[str, List[Tuple[str, int]]]) -> set:
        """Collect composite NL expressions using dependency parsing"""
        composites = set()

        for entity_type, entities in nl_entities.items():
            for entity_text, entity_pos in entities:
                composite = self.find_composite_nl_expression_via_dependencies(problem, entity_text, entity_pos)
                if composite:
                    composites.add(composite)

        return composites

    def _detect_all_candidates_with_composites(self, problem: str) -> List[Dict]:
        """Enhanced candidate detection that respects composite expressions from the original engines"""
        candidates = []

        # Use existing detection methods from individual engines
        nl_entities = self.nl_engine.detect_nl_entities(problem)
        math_topics = self.math_engine.detect_math_topics(problem)
        temporal_topics = self.temporal_engine.detect_temporal_topics(problem)

        # Collect composite expressions first using the restored sophisticated methods
        logger.debug(f"    üîç Collecting composite expressions...")
        all_composites = set()

        # Collect temporal composites
        temporal_composites = self.collect_composite_time_expressions(problem, temporal_topics)
        all_composites.update(temporal_composites)
        logger.debug(f"        Found {len(temporal_composites)} temporal composites")

        # Collect mathematical composites
        math_composites = self.collect_composite_expressions_via_deps(problem, math_topics)
        all_composites.update(math_composites)
        logger.debug(f"        Found {len(math_composites)} mathematical composites")

        # Collect NL composites
        nl_composites = self.collect_composite_nl_expressions_via_deps(problem, nl_entities)
        all_composites.update(nl_composites)
        logger.debug(f"        Found {len(nl_composites)} NL composites")

        logger.debug(f"        Total composites found: {len(all_composites)}")

        # Add composite expressions as high-priority candidates
        for composite in all_composites:
            composite_pos = problem.find(composite)
            if composite_pos != -1:
                # Determine domain based on content
                if any(time_word in composite.lower() for time_word in
                      ['hour', 'minute', 'second', 'day', 'week', 'month', 'year']):
                    domain = 'temporal'
                    topic = 'composite_time_expression'
                elif any(math_word in composite for math_word in ['+', '-', '*', '/', 'per', 'rate']):
                    domain = 'mathematical'
                    topic = 'composite_math_expression'
                else:
                    domain = 'nl'
                    topic = 'composite_nl_expression'

                candidates.append({
                    'text': composite,
                    'pos': composite_pos,
                    'domain': domain,
                    'topic': topic,
                    'is_composite': True,
                    'priority': 'high'
                })

        # Now add individual candidates that are NOT part of composites
        logger.debug(f"    üîç Adding individual candidates (skipping those in composites)...")

        # Add mathematical candidates
        for topic, matches in math_topics.items():
            for text, pos in matches:
                # Check if this individual match should be skipped due to being part of a composite
                if not self.should_skip_individual_transformation_via_deps(problem, text, pos):
                    candidates.append({'text': text, 'pos': pos, 'domain': 'math', 'topic': topic})

        # Add temporal candidates
        for topic, matches in temporal_topics.items():
            for text, pos in matches:
                # Check if this individual match should be skipped due to being part of a composite
                if not self.should_skip_individual_transformation(problem, text, pos):
                    candidates.append({'text': text, 'pos': pos, 'domain': 'temporal', 'topic': topic})

        # Add NL candidates
        for entity_type, entities in nl_entities.items():
            for text, pos in entities:
                # Check if this individual match should be skipped due to being part of a composite
                if not self.should_skip_individual_nl_transformation_via_deps(problem, text, pos):
                    candidates.append({'text': text, 'pos': pos, 'domain': 'nl', 'topic': entity_type})

        logger.debug(f"    ‚úÖ Total candidates collected: {len(candidates)} (including {len(all_composites)} composites)")
        return candidates

    def _detect_all_candidates_batch(self, problems: List[str]) -> List[List[Dict]]:
        """
        Batch detect candidates for multiple problems at once.
        Uses spaCy batching for 10-50x speedup over sequential detection.

        IMPORTANT: This method applies EXACT SAME LOGIC as _detect_all_candidates_with_composites()
        but processes multiple problems together for performance.

        Args:
            problems: List of problem texts to process

        Returns:
            List of candidate lists, one per problem (same format as _detect_all_candidates_with_composites)
        """
        logger.debug(f"    üöÄ Batch detecting candidates for {len(problems)} problems...")

        # Step 1: Batch NL entity detection (FAST with spaCy pipe)
        logger.debug(f"        üì¶ Batch detecting NL entities...")
        nl_entities_batch = self.nl_engine.detect_nl_entities_batch(problems)

        # Step 2: Batch math/temporal detection (regex is fast, can do sequentially)
        logger.debug(f"        üì¶ Detecting math/temporal topics...")
        math_topics_batch = [self.math_engine.detect_math_topics(p) for p in problems]
        temporal_topics_batch = [self.temporal_engine.detect_temporal_topics(p) for p in problems]

        # Step 3: Process each problem's results with EXACT SAME LOGIC as original method
        all_candidates = []
        for i, problem in enumerate(problems):
            nl_entities = nl_entities_batch[i]
            math_topics = math_topics_batch[i]
            temporal_topics = temporal_topics_batch[i]

            candidates = []

            # Collect composite expressions first - SAME LOGIC
            logger.debug(f"        üîç Problem {i+1}: Collecting composite expressions...")
            all_composites = set()

            # Collect temporal composites - SAME LOGIC
            temporal_composites = self.collect_composite_time_expressions(problem, temporal_topics)
            all_composites.update(temporal_composites)

            # Collect mathematical composites - SAME LOGIC
            math_composites = self.collect_composite_expressions_via_deps(problem, math_topics)
            all_composites.update(math_composites)

            # Collect NL composites - SAME LOGIC
            nl_composites = self.collect_composite_nl_expressions_via_deps(problem, nl_entities)
            all_composites.update(nl_composites)

            # Add composite expressions as high-priority candidates - SAME LOGIC
            for composite in all_composites:
                composite_pos = problem.find(composite)
                if composite_pos != -1:
                    # Determine domain based on content - SAME LOGIC
                    if any(time_word in composite.lower() for time_word in
                          ['hour', 'minute', 'second', 'day', 'week', 'month', 'year']):
                        domain = 'temporal'
                        topic = 'composite_time_expression'
                    elif any(math_word in composite for math_word in ['+', '-', '*', '/', 'per', 'rate']):
                        domain = 'mathematical'
                        topic = 'composite_math_expression'
                    else:
                        domain = 'nl'
                        topic = 'composite_nl_expression'

                    candidates.append({
                        'text': composite,
                        'pos': composite_pos,
                        'domain': domain,
                        'topic': topic,
                        'is_composite': True,
                        'priority': 'high'
                    })

            # Now add individual candidates that are NOT part of composites - SAME LOGIC
            # Add mathematical candidates
            for topic, matches in math_topics.items():
                for text, pos in matches:
                    # Check if this individual match should be skipped - SAME LOGIC
                    if not self.should_skip_individual_transformation_via_deps(problem, text, pos):
                        candidates.append({'text': text, 'pos': pos, 'domain': 'math', 'topic': topic})

            # Add temporal candidates
            for topic, matches in temporal_topics.items():
                for text, pos in matches:
                    # Check if this individual match should be skipped - SAME LOGIC
                    if not self.should_skip_individual_transformation(problem, text, pos):
                        candidates.append({'text': text, 'pos': pos, 'domain': 'temporal', 'topic': topic})

            # Add NL candidates
            for entity_type, entities in nl_entities.items():
                for text, pos in entities:
                    # Check if this individual match should be skipped - SAME LOGIC
                    if not self.should_skip_individual_nl_transformation_via_deps(problem, text, pos):
                        candidates.append({'text': text, 'pos': pos, 'domain': 'nl', 'topic': entity_type})

            logger.debug(f"        ‚úÖ Problem {i+1}: {len(candidates)} candidates collected (including {len(all_composites)} composites)")
            all_candidates.append(candidates)

        logger.debug(f"    ‚úÖ Batch detection complete: {len(all_candidates)} problems processed")
        return all_candidates

    # Legacy wrapper
    def generate_debugging_focused_variations(self, problem: str, **kwargs):
        """Legacy wrapper for debugging-focused variations."""
        return self.generate_comprehensive_variations(problem, organize_by="debugging_capabilities", **kwargs)